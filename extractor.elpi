%

macro @level :- int.
%%macro @level :- ext.

type extractor_singleton mttType.
type extractor_star mttTerm.

ofType extractor_singleton props @level.
of extractor_star extractor_singleton @level.

%% Typing extensions to type extractor terms

dconv propS extractor_singleton.
dconv extractor_singleton propS.
%of (encode T) extractor_singleton IE :- makeline, ofType T props IE.
%ofType (decode T) props IE :- makeline, of T extractor_singleton IE.

type var_term     any -> any -> mttTerm.
type var_type     any -> any -> mttTerm.
type var_dep_term any -> any -> any -> mttTerm.
type var_dep_type any -> any -> any -> mttTerm.

kind var_mapping_type type.
type var_mapping A -> A -> var_mapping_type.

kind lib_mapping_type type.
type lib_mapping libraryEntry -> libraryEntry -> list prop -> lib_mapping_type.

kind context_type type.
type context list mttTerm -> list var_mapping_type -> list lib_mapping_type -> context_type.

%% Library translation interface

translate_program_list [H|TL] LibMap [H'|TL']
    :- translate_program H LibMap H'
    ,  translate_program_list TL LibMap TL'
    .
translate_program_list [] _ [].

filter_code (extractor_type_lambda B F) Result
    :- pi Bi\ ofType Bi B int => filter_code (F Bi) Result
    .
filter_code (lambda B F) true
    :- pi x\ locDecl x B => ((F x) = x)
    .
filter_code _ false.

filter_code_list [H|TL] Result
    :- spy(filter_code H Delete)
    ,  filter_code_list TL TL'
    ,  ((Delete = true, Result = TL'), !; Result = [H|TL'])
    .
filter_code_list [] [].

translate_entry Entry LibMap ExtrEntry OutLib Result
    :- Context = (context [] [] LibMap)
    ,  spy(starify_lib Entry LibMap StarEntry)
    ,  spy(extract_lib StarEntry ExtrEntry Context ArgMask [] OutList)
    ,  spy(translate_lib ExtrEntry [] LibMap Code)
%    ,  spy(filter_code_list OutList OutList')
    ,  spy(translate_program_list OutList LibMap CodeList)
    ,  concat [[Code], CodeList] Result
    ,  spy(get_call_signature StarEntry StarEntry')
    ,  spy(get_call_signature ExtrEntry ExtrEntry')
    ,  spy(concat [LibMap, [(lib_mapping StarEntry' ExtrEntry' ArgMask)]] OutLib)
    .

translate_library [Entry|TL] LibMap Result
    :- translate_entry Entry LibMap ExtrEntry ExtrLib Entry'
    ,  process_entry Entry Hyp
    ,  process_entry ExtrEntry ExtrHyp
    ,  Hyp => ExtrHyp => translate_library TL ExtrLib TL'
    ,  concat [Entry', TL'] Result
    .
translate_library [] _ [].

translate_entry_from_library [Entry|_TL] LibMap 0 Result
    :- makeline
    ,  debug => translate_entry Entry LibMap ExtrEntry _ Result
    ,  print ExtrEntry
    ,  !
    .
translate_entry_from_library [Entry|TL] LibMap Index Result
    :- spy(translate_entry Entry LibMap ExtrEntry ExtrLib _)
    ,  spy(process_entry Entry Hyp)
    ,  spy(process_entry ExtrEntry ExtrHyp)
    ,  NewIndex is (Index - 1)
    ,  Hyp => ExtrHyp => translate_entry_from_library TL ExtrLib NewIndex Result
    ,  !
    .
translate_entry_from_library [] _ _ [].

%% Lib Extraction

starify_lib (univPi F) LibMap Result
    :- pi Bi\ ofType Bi set int => starify_lib (F Bi) LibMap (F' Bi)
    ,  spy(Result = (univPi F')) 
    ,  !
    .
starify_lib (univCol F) LibMap Result
    :- spy(pi Bi\ ofType Bi col int => starify_lib (F Bi) LibMap (F' Bi))
    ,  spy(Result = (univCol F')) 
    ,  !
    .
starify_lib (univProp F) LibMap Result
    :- pi Bi\ ofType Bi props int => starify_lib (F Bi) LibMap (F' Bi)
    ,  spy(Result = (univProp F')) 
    ,  !
    .

starify_lib (univDepPi Bi F) LibMap Result
    :- starify_type Bi LibMap Bi'
    ,  spy(pi Ci\ (pi x\ ofType (Ci x) set int :- of x Bi int) =>
        (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) =>
            starify_lib (F Ci) LibMap (F' Ci))
    ,  spy(Result = (univDepPi Bi' F'))
    ,  !
    .
starify_lib (univDepCol Bi F) LibMap Result
    :- starify_type Bi LibMap Bi'
    ,  spy(pi Ci\ (pi x\ ofType (Ci x) col int :- of x Bi int) =>
        (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) =>
            starify_lib (F Ci) LibMap (F' Ci))
    ,  spy(Result = (univDepCol Bi' F'))
    ,  !
    .
starify_lib (univDepProp Bi F) LibMap Result
    :- starify_type Bi LibMap Bi'
    ,  spy(pi Ci\ (pi x\ ofType (Ci x) props int :- of x Bi int) =>
        (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) =>
            starify_lib (F Ci) LibMap (F' Ci))
    ,  spy(Result = (univDepProp Bi' F'))
    ,  !
    .

starify_lib (univPiT T F) LibMap Result
    :- starify_type T LibMap T'
    ,  spy(pi x\ of x T int => starify_lib (F x) LibMap (F' x))
    ,  spy(Result = (univPiT T' F')) 
    ,  !
    .

starify_lib (univDepPiT Ai Bi F) LibMap Result
    :- starify_type Ai LibMap Ai'
    ,  spy((name Bi, Bi' = Bi)
        , !; pi x\ of x Ai int => starify_type (Bi x) LibMap (Bi' x))
    ,  pi t\ (pi x\ ofType (Bi x) set int :- of x Ai int) =>
        (pi x\ pi y\ dconv (Bi x) (Bi y) :- conv x y) =>
            (pi x\ of (t x) (Bi x) int :- of x Ai int) =>
                starify_lib (F t) LibMap (F' t)
    ,  spy(Result = (univDepPiT Ai' Bi' F')) 
    ,  !
    .

starify_lib (locDefL N TY TE) LibMap Result
    :- spy(starify_type TY LibMap TY')
    ,  spy(starify_term TE LibMap TE')
    ,  spy(Result = (locDefL N TY' TE')) 
    ,  !
    .
starify_lib (locTypeDefL N KIND TY) LibMap Result
    :- spy(starify_type TY LibMap TY')
    ,  spy(Result = (locTypeDefL N KIND TY')) 
    ,  !
    .

%starify_lib_prop _ true.
starify_lib_prop A A.

starify_lib (hyp H1 H2 E) LibMap Result
    :- starify_lib_prop H1 H1'
    ,  starify_lib_prop H2 H2'
    ,  (H1' => starify_lib E LibMap E')
    ,  spy(Result = (hyp H1' H2' E')) 
    ,  !
    .
starify_lib (cut H E) LibMap Result
    :- starify_lib_prop H H'
    ,  (process_cut H' Hyp, Hyp => starify_lib E LibMap E')
    ,  spy(Result = (cut H' E')) 
    ,  !
    .


conditional_fail Bool :- Bool = true.

type not_occurs A -> B -> prop.
not_occurs V T :- ((occurs V T, Result = false), !; Result = true), conditional_fail Result.

kind body_type type.
type body A -> body_type.

type erase_absent_arg B -> C -> list body_type -> B -> prop.
erase_absent_arg H' Arg [body HD|BodyTL] Result
    :- not_occurs Arg HD
    ,  erase_absent_arg H' Arg BodyTL Result
    ,  Result = H'
    ,  !
    .
erase_absent_arg H' _ [] H'
    :- !
    .
erase_absent_arg H' Arg _ (lib_app H' Arg).

type erase_absent_args B -> list body_type -> B -> prop.
erase_absent_args (lib_app H Arg) BodyList Result
    :- erase_absent_args H BodyList H'
    ,  erase_absent_arg H' Arg BodyList Result
    ,  !
    .
erase_absent_args H _ H.

%% N -> K  ==>  K
collapse_lib (univPi F) Result _ false _ []
    :- pi Bi\ ofType Bi set int => (not_occurs Bi (F Bi), Result = (F Bi))
    ,  !
    .
extract_lib (univPi F) Result Context [TakeArg|ArgMask] BodyList SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(pi Bi\ ofType Bi set int => extract_lib (F Bi) (F' Bi)
                                       (context [var_type Bi _|Vars] VarMap LibMap)
                                       ArgMask BodyList SetList)
    ,  spy(collapse_lib (univPi F') Result Context TakeArg BodyList [])
    ,  !
    .

%% N -> K  ==>  K
collapse_lib (univCol F) Result _ false _ []
    :- pi Bi\ ofType Bi col int => (not_occurs Bi (F Bi), Result = (F Bi))
    ,  !
    .
extract_lib (univCol F) Result Context [TakeArg|ArgMask] BodyList SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(pi Bi\ ofType Bi col int => extract_lib (F Bi) (F' Bi)
                                       (context [var_type Bi _|Vars] VarMap LibMap)
                                       ArgMask BodyList SetList)
    ,  spy(collapse_lib (univCol F') Result Context TakeArg BodyList [])
    ,  !
    .

%% T(1) -> N  ==>  N
collapse_lib (univProp F) Result Context false BodyList SetList
    :- spy(extract_lib (F extractor_singleton) Result Context _ArgMask BodyList SetList)
    ,  !
    .
extract_lib (univProp F) Result Context [TakeArg|ArgMask] BodyList SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(pi Bi\ ofType Bi props int => extract_lib (F Bi) (F' Bi)
                                         (context [var_type Bi _|Vars] VarMap LibMap)
                                         ArgMask BodyList FList)
    ,  spy(collapse_lib (univProp F') Result Context TakeArg BodyList AppList)
    ,  spy(concat [AppList, FList] SetList)
    ,  !
    .


%% N -> K  ==>  K
collapse_lib (univDepPi Bi F) Result _ false _ []
    :- pi x\ of x Bi int => pi Ci\ (pi x\ ofType (Ci x) set int :- of x Bi int) =>
        (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) => (not_occurs Ci (F Ci), Result = (F Ci))
    ,  !
    .
extract_lib (univDepPi Bi F) Result Context [TakeArg|ArgMask] BodyList SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(extract_type Bi Bi' Context BiList)
    ,  spy(pi x\ of x Bi int => pi Ci\ (pi x\ ofType (Ci x) set int :- of x Bi int) =>
           pi y\ of y Bi' int => pi Ei\ (pi y\ ofType (Ei y) set int :- of y Bi' int) =>
            (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) =>
            (pi x\ pi y\ dconv (Ei x) (Ei y) :- conv x y) =>
                extract_lib (F Ci) (F' Ei)
                (context [var_dep_type Ei _ y|[var_dep_type Ci _ x|Vars]]
                         [var_mapping Ci Ei|[var_mapping x y|VarMap]]
                         LibMap)
                ArgMask BodyList FList)
    ,  spy(concat [FList, BiList] SetList)
    ,  spy(collapse_lib (univDepPi Bi' F') Result Context TakeArg BodyList [])
    ,  !
    .

%% N -> K  ==>  K
collapse_lib (univDepCol Bi F) Result _ false _ []
    :- pi x\ of x Bi int => pi Ci\ (pi x\ ofType (Ci x) col int :- of x Bi int) =>
        (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) => (not_occurs Ci (F Ci), Result = (F Ci))
    ,  !
    .
extract_lib (univDepCol Bi F) Result Context [TakeArg|ArgMask] BodyList SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(extract_type Bi Bi' Context BiList)
    ,  spy(pi x\ of x Bi int => pi Ci\ (pi x\ ofType (Ci x) col int :- of x Bi int) =>
           pi y\ of y Bi' int => pi Ei\ (pi y\ ofType (Ei y) col int :- of y Bi' int) =>
            (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) =>
            (pi x\ pi y\ dconv (Ei x) (Ei y) :- conv x y) =>
                extract_lib (F Ci) (F' Ei)
                (context [var_dep_type Ei _ y|[var_dep_type Ci _ x|Vars]]
                         [var_mapping Ci Ei|[var_mapping x y|VarMap]]
                         LibMap)
                ArgMask BodyList FList)
    ,  spy(concat [FList, BiList] SetList)
    ,  spy(collapse_lib (univDepCol Bi' F') Result Context TakeArg BodyList [])
    ,  !
    .

%% T(1) -> N  ==>  N
collapse_lib (univDepProp _Bi F) Result Context false BodyList SetList
    :- spy(extract_lib (F (_\extractor_singleton)) Result Context _ArgMask BodyList SetList)
    ,  !
    .
extract_lib (univDepProp Bi F) Result Context [TakeArg|ArgMask] BodyList SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(extract_type Bi Bi' Context BiList)
    ,  spy(pi x\ of x Bi int => pi Ci\ (pi x\ ofType (Ci x) props int :- of x Bi int) =>
           pi y\ of y Bi' int => pi Ei\ (pi y\ ofType (Ei y) props int :- of y Bi' int) =>
            (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) =>
            (pi x\ pi y\ dconv (Ei x) (Ei y) :- conv x y) =>
                extract_lib (F Ci) (F' Ei)
                (context [var_dep_type Ei _ y|[var_dep_type Ci _ x|Vars]]
                         [var_mapping Ci Ei|[var_mapping x y|VarMap]]
                         LibMap)
                ArgMask BodyList FList)
    ,  spy(concat [FList, BiList] SetList)
    ,  spy(collapse_lib (univDepProp Bi' F') Result Context TakeArg BodyList [])
    ,  !
    .

%% 1 -> N  ==>  N
collapse_lib (univPiT T F) Result Context false BodyList SetList
    :- conv T extractor_singleton
    ,  spy(extract_lib (F extractor_star) Result Context _ArgMask BodyList SetList)
    ,  !
    .
%% N -> K  ==>  K
collapse_lib (univPiT T F) Result _ false _ []
    :- pi x\ of x T int => (not_occurs x (F x), Result = (F x))
    ,  !
    .
extract_lib (univPiT T F) Result Context [TakeArg|ArgMask] BodyList SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(extract_type T T' Context TList)
    ,  spy(pi x\ of x T int => pi y\ of y T' int =>
            extract_lib (F x) (F' y)
            (context [var_term _ y|[var_term _ x|Vars]] [var_mapping x y|VarMap] LibMap)
            ArgMask BodyList FList)
    ,  spy(concat [FList, TList] SetList)
    ,  spy(collapse_lib (univPiT T' F') Result Context TakeArg BodyList [])
    ,  !
    .

%% 1 -> N  ==>  N
collapse_lib (univDepPiT _Ai Bi F) Result Context false BodyList SetList
    :- conv Bi (_\extractor_singleton)
    ,  spy(extract_lib (F (_\extractor_star)) Result Context _ArgMask BodyList SetList)
    ,  !
    .
%% N -> K  ==>  K
collapse_lib (univDepPiT Ai Bi F) Result _ false _ []
    :- pi x\ of x Ai int => pi t\ (pi x\ ofType (Bi x) set int :- of x Ai int) =>
        (pi x\ pi y\ dconv (Bi x) (Bi y) :- conv x y) =>
            (pi x\ of (t x) (Bi x) int :- of x Ai int) => (not_occurs t (F t), Result = (F t))
    ,  !
    .
extract_lib (univDepPiT Ai Bi F) Result Context [TakeArg|ArgMask] BodyList SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(extract_type Ai Ai' Context AiList)
    ,  spy((name Bi, Bi' = Bi, BiList = [])
        , !; pi x\ of x Ai int => pi y\ of y Ai' int =>
            extract_type (Bi x) (Bi' y)
            (context [var_term _ y|[var_term _ x|Vars]] [var_mapping x y|VarMap] LibMap)
            BiList)
    ,  pi x\ of x Ai int => pi t\ (pi x\ ofType (Bi x) set int :- of x Ai int) =>
       pi y\ of y Ai' int => pi g\ (pi y\ ofType (Bi' y) set int :- of y Ai' int) =>
        (pi x\ pi y\ dconv (Bi x) (Bi y) :- conv x y) =>
        (pi x\ pi y\ dconv (Bi' x) (Bi' y) :- conv x y) =>
            (pi x\ of (t x) (Bi x) int :- of x Ai int) =>
            (pi y\ of (g y) (Bi' y) int :- of y Ai' int) =>
                spy(extract_lib (F t) (F' g)
                    (context [var_dep_term Bi' g y|[var_dep_term Bi t x|Vars]]
                             [var_mapping t g|[var_mapping x y|VarMap]]
                             LibMap)
                    ArgMask BodyList FList)
    ,  spy(concat [FList, BiList, AiList] SetList) 
    ,  spy(collapse_lib (univDepPiT Ai' Bi' F') Result Context TakeArg BodyList [])
    ,  !
    .


% elimina argomenti inutilizzati
collapse_lib (locDefL N TY TE) Result _ true BodyList []
    :- spy(erase_absent_args N [body TE|[body TY|BodyList]] N')
    ,  Result = (locDefL N' TY TE)
    ,  !
    .
extract_lib (locDefL N TY TE) Result Context [] BodyList SetList
    :- spy(extract_lib_def N N' Context [])
    ,  spy(extract_type TY TY' Context TYList)
    ,  spy(extract_term TE TE' Context TEList)
    ,  spy(concat [TEList, TYList] SetList)
    ,  spy(collapse_lib (locDefL N' TY' TE') Result Context true BodyList [])
    ,  !
    .

% elimina argomenti inutilizzati
collapse_lib (locTypeDefL N KIND TY) Result _ true BodyList []
    :- spy(erase_absent_args N [body TY|BodyList] N')
    ,  Result = (locTypeDefL N' KIND TY)
    ,  !
    .
extract_lib (locTypeDefL N _KIND TY) Result Context [] BodyList SetList
    :- spy(extract_lib_def N N' Context [])
    ,  spy(extract_type TY TY' Context SetList)
    ,  spy(ofType TY' KIND' @level)
    ,  spy(collapse_lib (locTypeDefL N' KIND' TY') Result Context true BodyList [])
    ,  !
    .



%% prop extraction begin: prop extraction assumes that no extraction of reabstreacted terms is needed
construct_implication_ [H|[]] Result
    :- Result = H
    ,  !
    .
construct_implication_ [H|TL] Result
    :- construct_implication_ TL TL'
    ,  Result = (H => TL')
    .
construct_implication List Result
    :- reverse List RList
    ,  spy(construct_implication_ RList Result)
    .
 
extract_lib_prop (pi a\ H a) Result Context NewDecl
    :- Context = (context Vars VarMap LibMap)
    ,  pi a\ pi b\ spy(extract_lib_prop (H a) (H' b)
                       (context Vars [(var_mapping a b)|VarMap] LibMap)
                       NewDecl)
    ,  spy(Result = (pi b\ H' b))
    ,  !
    .
extract_lib_prop (isa X T @level) Result Context [(locDecl X' T')|[(locDecl X T)]]
    :- spy(extract_term X X' Context [])
    ,  spy(extract_type T T' Context [])
    ,  spy(Result = (isa X' T' @level))
    ,  !
    .
extract_lib_prop (locDecl X T) Result Context []
    :- spy(extract_term X X' Context [])
    ,  spy(extract_type T T' Context [])
    ,  spy(Result = (locDecl X' T'))
    ,  !
    .
extract_lib_prop (A => B) Result Context NewDecl
    :- spy(extract_lib_prop A A' Context ADecl)
    ,  spy(construct_implication [extract_lib_prop B B' Context NewDecl|[A'|[A|ADecl]]] ImpliesB)
    ,  spy(ImpliesB)
    ,  spy(Result = (A' => B'))
    ,  !
    .
extract_lib_prop (conv A B) Result Context []
    :- spy(extract_term A A' Context [])
    ,  spy(extract_term B B' Context [])
    ,  spy(Result = (conv A' B'))
    ,  !
    .
extract_lib_prop (conv_trans X Y Z) Result Context []
    :- spy(extract_term X X' Context [])
    ,  spy(extract_term Y Y' Context [])
    ,  spy(extract_term Z Z' Context [])
    ,  spy(Result = (conv_trans X' Y' Z'))
    ,  !
    .
extract_lib_prop (conv_trans_symm X Y Z) Result Context []
    :- spy(extract_term X X' Context [])
    ,  spy(extract_term Y Y' Context [])
    ,  spy(extract_term Z Z' Context [])
    ,  spy(Result = (conv_trans_symm X' Y' Z'))
    ,  !
    .
extract_lib_prop (conv_symm X Y) Result Context []
    :- spy(extract_term X X' Context [])
    ,  spy(extract_term Y Y' Context [])
    ,  spy(Result = (conv_symm X' Y'))
    ,  !
    .
extract_lib_prop (spy A) Result Context NewDecl
    :- spy(extract_lib_prop A A' Context NewDecl)
    ,  spy(Result = (spy A'))
    ,  !
    .
extract_lib_prop true true _ [].

get_call_type (hyp _ _ E) Result :- get_call_type E Result.
get_call_type (cut _ E) Result :- get_call_type E Result.
get_call_type (locTypeDefL _ _ T) T.
get_call_type (locDefL _ T _) T.
%% prop extraction end

collapse_lib (hyp _ _ E) Result Context true BodyList []
    :- get_call_type E T
    ,  conv T extractor_singleton
    ,  extract_lib E Result Context _ArgMask BodyList []
    ,  !
    .

extract_lib (hyp H1 H2 E) Result Context ArgMask BodyList SetList
    :- spy(extract_lib_prop H1 H1' Context _)
    ,  spy(extract_lib_prop H2 H2' Context _)
    ,  spy(H1 => H1' => extract_lib E E' Context ArgMask [body H2'|[body H1'|BodyList]] SetList)
    ,  spy(collapse_lib (hyp H1' H2' E') Result Context true BodyList [])
    ,  !
    .

collapse_lib (cut _ E) Result Context true BodyList []
    :- get_call_type E T
    ,  conv T extractor_singleton
    ,  extract_lib E Result Context _ArgMask BodyList []
    ,  !
    .

extract_lib (cut H E) Result Context ArgMask BodyList SetList
    :- spy(extract_lib_prop H H' Context _)
    ,  spy(process_cut H Hyp)
    ,  spy(process_cut H' Hyp')
    ,  spy(Hyp => Hyp' => extract_lib E E' Context ArgMask [body H'|BodyList] SetList)
    ,  spy(collapse_lib (cut H' E') Result Context true BodyList [])
    ,  !
    .


%% Base cases definition for extraction

type get_call_name any -> any -> prop.
get_call_name (univPi F) Result :- get_call_name (F X_) Result.
get_call_name (univCol F) Result :- get_call_name (F X_) Result.
get_call_name (univProp F) Result :- get_call_name (F X_) Result.
get_call_name (univDepPi _ F) Result :- get_call_name (F X_) Result.
get_call_name (univDepCol _ F) Result :- get_call_name (F X_) Result.
get_call_name (univDepProp _ F) Result :- get_call_name (F X_) Result.
get_call_name (univPiT _ F) Result :- get_call_name (F X_) Result.
get_call_name (univDepPiT _ _ F) Result :- get_call_name (F X_) Result.
get_call_name (hyp _ _ E) Result :- get_call_name E Result.
get_call_name (cut _ E) Result :- get_call_name E Result.
get_call_name (locTypeDefL N _ _) Result :- get_call_name N Result.
get_call_name (locDefL N _ _) Result :- get_call_name N Result.
get_call_name (lib_app H _) Result :- get_call_name H Result.
get_call_name H H.

type is_lib_call A -> list lib_mapping_type -> libraryEntry -> prop.
is_lib_call AName [(lib_mapping Call _ _)|Tail] Call'
    :- get_call_name Call Name
    ,  ((AName = Name, Call' = Call), !; is_lib_call AName Tail Call')
    .
type is_extrlib_call A -> list lib_mapping_type -> libraryEntry -> prop.
is_extrlib_call AName [(lib_mapping _ Call _)|Tail] Call'
    :- get_call_name Call Name
    ,  ((AName = Name, Call' = Call), !; is_extrlib_call AName Tail Call')
    .


type stylized_type_of libraryEntry -> list any -> list mttTerm -> prop.

stylized_type_of (univPi F) [Arg|ArgTL] [var_type _ _|KindTL]
    :- (isaType Arg set int => stylized_type_of (F Arg) ArgTL KindTL)
    ,  !
    .
stylized_type_of (univCol F) [Arg|ArgTL] [var_type _ _|KindTL]
    :- (isaType Arg col int => stylized_type_of (F Arg) ArgTL KindTL)
    ,  !
    .
stylized_type_of (univProp F) [Arg|ArgTL] [var_type _ _|KindTL]
    :- (isaType Arg props int => stylized_type_of (F Arg) ArgTL KindTL)
    ,  !
    .

stylized_type_of (univDepPi Bi F) [Arg|ArgTL] [var_dep_type _ _ Bi|KindTL]
    :- (pi x\ isaType (Arg x) set int :- of x Bi int) =>
        (pi x\ pi y\ dconv (Arg x) (Arg y) :- conv x y) => stylized_type_of (F Arg) ArgTL KindTL
    ,  !
    .
stylized_type_of (univDepCol Bi F) [Arg|ArgTL] [var_dep_type _ _ Bi|KindTL]
    :- (pi x\ isaType (Arg x) col int :- of x Bi int) =>
        (pi x\ pi y\ dconv (Arg x) (Arg y) :- conv x y) => stylized_type_of (F Arg) ArgTL KindTL
    ,  !
    .
stylized_type_of (univDepProp Bi F) [Arg|ArgTL] [var_dep_type _ _ Bi|KindTL]
    :- (pi x\ isaType (Arg x) props int :- of x Bi int) =>
        (pi x\ pi y\ dconv (Arg x) (Arg y) :- conv x y) => stylized_type_of (F Arg) ArgTL KindTL
    ,  !
    .

stylized_type_of (univPiT T F) [Arg|ArgTL] [var_term _ _|KindTL]
    :- (isa Arg T int => stylized_type_of (F Arg) ArgTL KindTL)
    ,  !
    .

stylized_type_of (univDepPiT Ai Bi F) [Arg|ArgTL] [var_dep_term _ _ Ai|KindTL]
    :- (pi x\ ofType (Bi x) set int :- of x Ai int) =>
        (pi x\ pi y\ dconv (Bi x) (Bi y) :- conv x y) =>
            (pi x\ isa (Arg x) (Bi x) int :- of x Ai int) => stylized_type_of (F Arg) ArgTL KindTL
    ,  !
    .

stylized_type_of (hyp H1 _ E) ArgTL KindTL
    :- (H1 => stylized_type_of E ArgTL KindTL)
    ,  !
    .
stylized_type_of (cut H E) ArgTL KindTL
    :- (process_cut H Hyp, Hyp => stylized_type_of E ArgTL KindTL)
    ,  !
    .

stylized_type_of (locDefL _ _ _) [] [].
stylized_type_of (locTypeDefL _ _ _) [] [].

type starify_arg mttTerm -> B -> list lib_mapping_type -> B -> prop.

starify_arg (var_type _ _) A LibMap Result
    :- starify_type A LibMap Result
    ,  !
    .
starify_arg (var_term _ _) A LibMap Result
    :- starify_term A LibMap Result
    ,  !
    .
starify_arg (var_dep_type _ _ X) A LibMap Result
    :-  spy((name A, A' = A)
        , !; pi x\ locDecl x X => starify_type (A x) LibMap (A' x))
    ,  Result = A'
    ,  !
    .
starify_arg (var_dep_term _ _ X) A LibMap Result
    :- spy((name A, A' = A)
        , !; pi x\ locDecl x X => starify_term (A x) LibMap (A' x))
    ,  Result = A'
    ,  !
    .

type starify_lib_call_ B -> list lib_mapping_type -> list any -> list mttTerm -> B -> prop.

starify_lib_call_ (lib_app H A) LibMap ArgList KindTL Result
    :- spy(starify_lib_call_ H LibMap ArgList [KindHD|KindTL] H')
    ,  spy(starify_arg KindHD A LibMap A')
    ,  Result = (lib_app H' A')
    ,  !
    .

starify_lib_call_ H LibMap ArgList Kind H
    :- is_lib_call H LibMap Hdef
    ,  spy(stylized_type_of Hdef ArgList Kind)
    .

type starify_lib_call B -> list lib_mapping_type -> B -> prop.

starify_lib_call A LibMap Result
    :- get_arg_list A ArgList
    ,  starify_lib_call_ A LibMap ArgList _ Result
    .

starify_type_ set A _ A :- !.
starify_type_ col propS _ extractor_singleton :- !.
starify_type_ col A _ A :- !.
starify_type_ _   A _ A :- spy(name A), !.
starify_type_ _   A Context Result :- starify_lib_call A Context Result, !.
%starify_type_ _   _ _ extractor_singleton.



starify_type (decode A) Context Result
    :- starify_term A Context A'
    ,  Result = (decode A')
    ,  !
    .

starify_type (lib_app H A) Context Result
    :- !
    ,  spy(starify_lib_call (lib_app H A) Context Result)
    ,  !
    .

starify_type (# X Y) Context Result
    :- of Y TY @level
    ,  ((name X, X' = X), !; pi y\ locDecl y TY => starify_type (X y) Context (X' y))
    ,  starify_term Y Context Y'
    ,  Result = (# X' Y')
    ,  !
    .

starify_type TA Context Result
    :- ofType TA AKind @level
    ,  spy(starify_type_ AKind TA Context Result)
    ,  !
    .

starify_term_ set A _ A :- !.
starify_term_ col A _ A :- !.
starify_term_ _   A _ A :- spy(name A), !.
starify_term_ _   A Context Result :- starify_lib_call A Context Result, !.
%starify_term_ _   _ _ extractor_star.

starify_term (encode A) Context Result
    :- starify_type A Context A'
    ,  Result = (encode A')
    ,  !
    .

starify_term (lib_app H A) Context Result
    :- !
    ,  spy(starify_lib_call (lib_app H A) Context Result)
    ,  !
    .

starify_term (# X Y) Context Result
    :- of Y TY @level
    ,  ((name X, X' = X), !; pi y\ locDecl y TY => starify_term (X y) Context (X' y))
    ,  starify_term Y Context Y'
    ,  Result = (# X' Y')
    ,  !
    .

starify_term (fixMe M T) Context Result
    :- starify_type T Context T'
    ,  Result = (fixMe M T')
    ,  !
    .

starify_term A Context Result
    :- of A TA @level
    ,  ofType TA AKind @level
    ,  spy(starify_term_ AKind A Context Result)
    ,  !
    .


type map_var B -> list var_mapping_type -> B -> prop.
map_var A [(var_mapping B C)|Tail] A' :- ((B = A, A' = C), !; map_var A Tail A').
map_var A [] A.

kind libGroup type.
type lib_source, lib_dest libGroup.

type map_var_group libGroup -> B -> list var_mapping_type -> B -> prop.
map_var_group Group A VarMap A'
    :- ((Group = lib_source, A' = A), !; Group = lib_dest, map_var A VarMap A')
    .


filter_args [ArgHead|ArgTail] [true|MaskTail] [ArgHead|ArgTail'] :- filter_args ArgTail MaskTail ArgTail'.
filter_args [_|ArgTail] [false|MaskTail] ArgTail' :- filter_args ArgTail MaskTail ArgTail'.
filter_args [] [] [].

type get_applied_head any -> list any -> any -> prop.
get_applied_head (univPi F) [H|TL] Result :- get_applied_head (F H) TL Result.
get_applied_head (univCol F) [H|TL] Result :- get_applied_head (F H) TL Result.
get_applied_head (univProp F) [H|TL] Result :- get_applied_head (F H) TL Result.
get_applied_head (univDepPi _ F) [H|TL] Result :- get_applied_head (F H) TL Result.
get_applied_head (univDepCol _ F) [H|TL] Result :- get_applied_head (F H) TL Result.
get_applied_head (univDepProp _ F) [H|TL] Result :- get_applied_head (F H) TL Result.
get_applied_head (univPiT _ F) [H|TL] Result :- get_applied_head (F H) TL Result.
get_applied_head (univDepPiT _ _ F) [H|TL] Result :- get_applied_head (F H) TL Result.
get_applied_head (hyp _ _ E) Args Result :- get_applied_head E Args Result.
get_applied_head (cut _ E) Args Result :- get_applied_head E Args Result.
get_applied_head (locTypeDefL N _ _) [] N.
get_applied_head (locDefL N _ _) [] N.

type map_lib_call_  any -> list any -> list lib_mapping_type -> any -> prop.
map_lib_call_ Name Args [lib_mapping Entry ExtrEntry ArgMask|Tail] Result
    :- spy(get_call_name Entry EntryName)
    ,  spy((Name = EntryName
        ,    filter_args Args ArgMask Args'
             , get_applied_head ExtrEntry Args' Result)
        , !; map_lib_call_ Name Args Tail Result)
    .

type get_arg_list A -> list any -> prop.
get_arg_list (lib_app H A) Result :- get_arg_list H List, concat [List, [A]] Result, !.
get_arg_list _H [].

type map_lib_call  any -> list lib_mapping_type -> any -> prop.
map_lib_call A LibMap Result
    :- spy(get_call_name A Name)
    ,  get_arg_list A Args
    ,  spy((term_to_string Name S, rex_match "^extr_[a-zA-Z0-9_]+$" S, Result = A)
        , !; map_lib_call_ Name Args LibMap Result)
    .

type extract_lib_def B -> B -> context_type -> list mttTerm -> prop.
extract_lib_def (lib_app H extractor_singleton) Result Context SetList
    :- spy(extract_lib_def H H' Context SetList)
    ,  spy(Result = H')
    ,  !
    .
extract_lib_def (lib_app H (_\extractor_singleton)) Result Context SetList
    :- spy(extract_lib_def H H' Context SetList)
    ,  spy(Result = H')
    ,  !
    .
extract_lib_def (lib_app H extractor_star) Result Context SetList
    :- spy(extract_lib_def H H' Context SetList)
    ,  spy(Result = H')
    ,  !
    .
extract_lib_def (lib_app H (_\extractor_star)) Result Context SetList
    :- spy(extract_lib_def H H' Context SetList)
    ,  spy(Result = H')
    ,  !
    .
extract_lib_def (lib_app H A) Result Context SetList
    :- Context = (context _ VarMap _)
    ,  spy(extract_lib_def H H' Context SetList)
    ,  spy(map_var A VarMap A') % in fase di dichiarazione l'argomento deve essere una variabile
    ,  spy(Result = (lib_app H' A'))
    ,  !
    .
extract_lib_def H Result _ []
    :- spy(term_to_string H S)
    ,  spy(rex_replace "^\\(extr_\\)?\\([a-zA-Z0-9_]+\\)$" "\\2" S SN)
    ,  spy(S' is "extr_" ^ SN)
    ,  spy(string_to_term S' Result)
    ,  !
    .

collapse_lib A A _ true _ [].

type extract_arg mttTerm -> B -> B -> context_type -> list mttTerm -> prop.

extract_arg (var_type _ _) A Result Context SetList
    :- spy(extract_type A Result Context SetList)
    ,  !
    .
extract_arg (var_term _ _) A Result Context SetList
    :- spy(extract_term A Result Context SetList)
    ,  !
    .
extract_arg (var_dep_type _ _ X) A Result Context SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy((name A, spy(map_var A VarMap A'), SetList = [])
        , !; extract_type X Y Context _,
             pi x\ locDecl x X => pi y\ locDecl y Y =>
                extract_type (A x) (A' y)
                (context [var_term _ y|[var_term _ x|Vars]] [var_mapping x y|VarMap] LibMap)
                SetList)
    ,  Result = A'
    ,  !
    .
extract_arg (var_dep_term _ _ X) A Result Context SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy((name A, map_var A VarMap A', SetList = [])
        , !; extract_type X Y Context _,
             pi x\ locDecl x X => pi y\ locDecl y Y =>
                extract_term (A x) (A' y)
                (context [var_term _ y|[var_term _ x|Vars]] [var_mapping x y|VarMap] LibMap)
                SetList)
    ,  Result = A'
    ,  !
    .

type extract_lib_call_ B -> B -> context_type -> list mttTerm -> list any -> list mttTerm -> prop.
type extract_lib_call B -> B -> context_type -> list mttTerm -> prop.

extract_lib_call_ (lib_app H A) Result Context ArgList KindTL SetList
    :- spy(extract_lib_call_ H H' Context ArgList [KindHD|KindTL] HList)
    ,  spy(extract_arg KindHD A A' Context AList)
    ,  concat [AList,HList] SetList
    ,  Result = (lib_app H' A')
    ,  !
    .
extract_lib_call_ H H Context ArgList Kind []
    :- term_to_string H S, rex_match "^extr_[a-zA-Z0-9_]+$" S
    ,  Context = (context _ _ LibMap)
    ,  is_extrlib_call H LibMap Hdef
    ,  spy(stylized_type_of Hdef ArgList Kind)
    .
extract_lib_call_ H H Context ArgList Kind []
    :- term_to_string H S, rex_match "^[a-zA-Z0-9_]+$" S
    ,  Context = (context _ _ LibMap)
    ,  is_lib_call H LibMap Hdef
    ,  spy(stylized_type_of Hdef ArgList Kind)
    .

extract_lib_call A Result Context SetList
    :- Context = (context _ _ LibMap)
    ,  get_arg_list A ArgList
    ,  spy(extract_lib_call_ A A' Context ArgList _ SetList)
    ,  spy(map_lib_call A' LibMap Result)
    ,  !
    .

/*
type contains_lib_app A -> prop -> prop.
contains_lib_app A true
    :- term_to_string A SA
    ,  rex_match "^.*lib_app .*$" SA
    ,  !
    .
contains_lib_app _ false.

type is_non_collapsible_lambda any -> prop.
is_non_collapsible_lambda (elim_setSum _ (inl _ _ A) Cl _) :- contains_lib_app (Cl A) true.
is_non_collapsible_lambda (elim_setSum _ (inr _ _ B) _ Cr) :- contains_lib_app (Cr B) true.
is_non_collapsible_lambda (elim_setSigma (pair _ _ B C) _ MM) :- contains_lib_app (MM B C) true.
is_non_collapsible_lambda _.
*/

type is_complexity_altered any -> prop.
is_complexity_altered _A
    :- @language = ocaml
%    ,  is_non_collapsible_lambda A
    .


collapse_type (decode extractor_star) Result _ []
    :- Result = extractor_singleton
    ,  !
    .
collapse_type (lib_app H A) Result _ []
    :- isaType (lib_app H A) props @level
    ,  Result = extractor_singleton
    ,  !
    .
collapse_type A Result _ []
    :- term_to_string A SA
    ,  rex_match "^extr_[a-zA-Z0-9_]+$" SA
    ,  isaType A props @level
    ,  Result = extractor_singleton
    ,  !
    .


collapse_type A A  _ [].

extract_type (decode A) Result Context SetList
    :- spy(extract_term A A' Context SetList)
    ,  spy(collapse_type (decode A') Result Context [])
    ,  !
    .

extract_type (lib_app H A) Result Context SetList
    :- spy(extract_lib_call (lib_app H A) (lib_app H' A') Context SetList)
    ,  spy(collapse_type (lib_app H' A') Result Context [])
    ,  !
    .

extract_type (# X Y) Result Context SetList
    :- Context = (context Vars VarMap LibMap)
    ,  spy(extract_term Y Y' Context YList)
    ,  spy(of Y TY @level), spy(of Y' TY' @level)
    ,  spy((name X, map_var X VarMap X', XList = [])
        , !; pi y\ locDecl y TY => pi s\ locDecl s TY' =>
            extract_type (X y) (X' s)
            (context [var_term _ s|[var_term _ y|Vars]] [var_mapping y s|VarMap] LibMap)
            XList)
    ,  spy(concat [YList, XList] SetList)
    ,  spy(collapse_type (# X' Y') Result Context [])
    .

extract_type extractor_singleton extractor_singleton _ [] :- !.
extract_type A Result Context []
    :- name A
    ,  Context = (context _ VarMap _)
    ,  map_var A VarMap Result
    ,  !
    .
extract_type H Result Context SetList
    :- spy(extract_lib_call H H' Context SetList)
    ,  spy(collapse_type H' Result Context [])
    ,  !
    .
%extract_type A A _ _ _ [].


collapse_term (encode extractor_singleton) Result _ []
    :- Result = extractor_star
    ,  !
    .
collapse_term (lib_app H A) Result _ []
    :- spy(isa (lib_app H A) extractor_singleton @level)
    ,  Result = extractor_star
    ,  !
    .

collapse_term (fixMe _M T) Result _ []
    :- conv T extractor_singleton
    ,  Result = extractor_star
    .

collapse_term A Result _ []
    :- term_to_string A SA
    ,  rex_match "^extr_[a-zA-Z0-9_]+$" SA
    ,  isa A extractor_singleton @level
    ,  Result = extractor_star
    ,  !
    .

collapse_term A A _ [].


extract_term (encode A) Result Context SetList
    :- spy(extract_type A A' Context SetList)
    ,  spy(collapse_term (encode A') Result Context [])
    ,  !
    .

extract_term (lib_app H A) Result Context SetList
    :- spy(extract_lib_call (lib_app H A) (lib_app H' A') Context SetList)
    ,  spy(collapse_term (lib_app H' A') Result Context [])
    ,  !
    .

extract_term (# X Y) Result Context SetList
    :- Context = (context Vars VarMap LibMap)
    ,  extract_term Y Y' Context YList
    ,  of Y TY @level, of Y' TY' @level
    ,  ((name X, map_var X VarMap X', XList = [])
        , !; pi y\ locDecl y TY => pi s\ locDecl s TY' =>
            extract_term (X y) (X' s)
            (context [var_term _ s|[var_term _ y|Vars]] [var_mapping y s|VarMap] LibMap)
            XList)
    ,  concat [YList, XList] SetList
    ,  collapse_term (# X' Y') Result Context []
    .

extract_term (fixMe M T) Result Context SetList
    :- extract_type T T' Context SetList
    ,  collapse_term (fixMe M T') Result Context []
    ,  !
    .

extract_term extractor_star extractor_star _ [] :- !.
extract_term A Result Context []
    :- name A
    ,  Context = (context _ VarMap _)
    ,  map_var A VarMap Result
    ,  !
    .
extract_term H Result Context SetList
    :- spy(extract_lib_call H H' Context SetList)
    ,  spy(collapse_term H' Result Context [])
    ,  !
    .
%extract_term A A _ _ _ [].

type get_call_signature any -> any -> prop.
get_call_signature (univPi F) (univPi F')
    :- pi Bi\ ofType Bi set int => get_call_signature (F Bi) (F' Bi)
    .
get_call_signature (univCol F) (univCol F')
    :- pi Bi\ ofType Bi set int => get_call_signature (F Bi) (F' Bi)
    .
get_call_signature (univProp F) (univProp F')
    :- pi Bi\ ofType Bi set int => get_call_signature (F Bi) (F' Bi)
    .
get_call_signature (univDepPi B F) (univDepPi B F')
    :- pi Ci\ (pi x\ ofType (Ci x) set int :- of x B int) =>
        (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) => get_call_signature (F Ci) (F' Ci)
    .
get_call_signature (univDepCol B F) (univDepCol B F')
    :- pi Ci\ (pi x\ ofType (Ci x) set int :- of x B int) =>
        (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) => get_call_signature (F Ci) (F' Ci)
    .
get_call_signature (univDepProp B F) (univDepProp B F')
    :- pi Ci\ (pi x\ ofType (Ci x) set int :- of x B int) =>
        (pi x\ pi y\ dconv (Ci x) (Ci y) :- conv x y) => get_call_signature (F Ci) (F' Ci)
    .
get_call_signature (univPiT A F) (univPiT A F')
    :- pi a\ of a A int => get_call_signature (F a) (F' a)
    .
get_call_signature (univDepPiT A B F) (univDepPiT A B F')
    :- pi t\ (pi x\ ofType (B x) set int :- of x A int) =>
        (pi x\ pi y\ dconv (B x) (B y) :- conv x y) =>
            (pi x\ of (t x) (B x) int :- of x A int) => get_call_signature (F t) (F' t)
    .
get_call_signature (hyp _ _ E) E' :- get_call_signature E E'.
get_call_signature (cut _ E) E' :- get_call_signature E E'.
get_call_signature (locTypeDefL N _ _) (locTypeDefL N _ _).
get_call_signature (locDefL N _ _) (locDefL N _ _).

%% Extraction of terms that goes into star

is_informative set true.
is_informative col true.
is_informative props false.
is_informative propc false.

reabstract_term (extractor_type_lambda K F) H M Context Result
    :- spy((name F, reabstract_dep_term F H M Context F')
        , !; pi Bi\ (isaType Bi K int) => reabstract_term (F Bi) H M Context (F' Bi))
    ,  spy(Result = (extractor_type_lambda K F'))
    ,  !
    .
reabstract_term (extractor_dep_type_lambda A K F) H M Context Result
    :- reabstract_type A H M Context A'
    ,  spy((name F, reabstract_dep_term F H M Context F')
        , !; pi a\ of a A int => pi Bi\ (isaType (Bi a) K int) => reabstract_term (F Bi) H M Context (F' Bi))
    ,  spy(Result = (extractor_dep_type_lambda A' K F'))
    ,  !
    .
reabstract_term (extractor_dep_lambda A B F) H M Context Result
    :- reabstract_type A H M Context A'
    ,  spy((name B, reabstract_dep_type B H M Context B')
        , !; pi a\ of a A int => reabstract_type (B a) H M Context (B' a))
    ,  spy((name F, reabstract_dep_term F H M Context F')
        , !; pi a\ of a A int => pi b\ (of (b a) (B a) int) => reabstract_term (F b) H M Context (F' b))
    ,  spy(Result = (extractor_dep_lambda A' B' F'))
    ,  !
    .


reabstract_type (setPi B C) H M Context Result
    :- reabstract_type B H M Context B'
    ,  ((name C, reabstract_dep_type C H M Context C')
        , !; pi b\ locDecl b B => reabstract_type (C b) H M Context (C' b))
    ,  spy(Result = (setPi B' C'))
    ,  !
    .
reabstract_term (lambda B F) H M Context Result
    :- spy(reabstract_type B H M Context B')
    ,  spy((name F, reabstract_dep_term F H M Context F')
        , !; pi b\ locDecl b B => reabstract_term (F b) H M Context (F' b))
    ,  spy(Result = (lambda B' F'))
    ,  !
    .
reabstract_term (app Lam X) H M Context Result
    :- reabstract_term Lam H M Context Lam'
    ,  reabstract_term X H M Context X'
    ,  spy(Result = (app Lam' X'))
    ,  !
    .

reabstract_type (setSigma B C) H M Context Result
    :- reabstract_type B H M Context B'
    ,  ((name C, reabstract_dep_type C H M Context C')
        , !; pi b\ locDecl b B => reabstract_type (C b) H M Context (C' b))
    ,  spy(Result = (setSigma B' C'))
    ,  !
    .
reabstract_term (pair B C BB CC) H M Context Result
    :- reabstract_type (setSigma B C) H M Context (setSigma B' C')
    ,  reabstract_term BB H M Context BB'
    ,  reabstract_term CC H M Context CC'
    ,  spy(Result = (pair B' C' BB' CC')) 
    ,  !
    .
reabstract_term (p1 Pair) H M Context Result
    :- reabstract_term Pair H M Context Pair'
    ,  Result = (p1 Pair') 
    ,  !
    .
reabstract_term (p2 Pair) H M Context Result
    :- reabstract_term Pair H M Context Pair'
    ,  Result = (p2 Pair') 
    ,  !
    .
reabstract_term (elim_setSigma Pair MT MM) H M Context Result
    :- reabstract_term Pair H M Context Pair'
    ,  isa Pair (setSigma B C) @level
    ,  ((name MT, reabstract_dep_type MT H M Context MT')
        , !; pi p\ locDecl p (setSigma B C) => reabstract_type (MT p) H M Context (MT' p))
    ,  ((pi b\ locDecl b B => (name (MM b), reabstract_dep_term (MM b) H M Context (MM' b)))
        , !; pi b\ pi c\ locDecl b B => locDecl c (C b) => reabstract_term (MM b c) H M Context (MM' b c))
    ,  Result = (elim_setSigma Pair' MT' MM')
    ,  !
    .

reabstract_type (setSum A B) H M Context Result
    :- reabstract_type A H M Context A'
    ,  reabstract_type B H M Context B'
    ,  Result = (setSum A' B')
    ,  !
    .
reabstract_term (inl A B AA) H M Context Result
    :- reabstract_type A H M Context A'
    ,  reabstract_type B H M Context B'
    ,  reabstract_term AA H M Context AA'
    ,  Result = (inl A' B' AA')
    ,  !
    .
reabstract_term (inr A B BB) H M Context Result
    :- reabstract_type A H M Context A'
    ,  reabstract_type B H M Context B'
    ,  reabstract_term BB H M Context BB'
    ,  Result = (inr A' B' BB')
    ,  !
    .
reabstract_term (elim_setSum C W Cl Cr) H M Context Result
    :- reabstract_term W H M Context W'
    ,  isa W (setSum L R) @level
    ,  ((name C, reabstract_dep_type C H M Context C')
        , !; pi w\ locDecl w (setSum L R) => reabstract_type (C w) H M Context (C' w))
    ,  ((name Cl, reabstract_dep_term Cl H M Context Cl')
        , !; pi l\ locDecl l L => reabstract_term (Cl l) H M Context (Cl' l))
    ,  ((name Cr, reabstract_dep_term Cr H M Context Cr')
        , !; pi r\ locDecl r R => reabstract_term (Cr r) H M Context (Cr' r)) 
    ,  Result = (elim_setSum C' W' Cl' Cr')
    ,  !
    .

reabstract_type (list C) H M Context Result
    :- reabstract_type C H M Context C'
    ,  Result = (list C')
    ,  !
    .
reabstract_term (list_empty C) H M Context Result
    :- reabstract_type C H M Context C'
    ,  Result = (list_empty C')
    ,  !
    .
reabstract_term (list_cons C Head Tail) H M Context Result
    :- reabstract_type C H M Context C'
    ,  reabstract_term Head H M Context Head'
    ,  reabstract_term Tail H M Context Tail'
    ,  Result = (list_cons C' Head' Tail')
    ,  !
    .
reabstract_term (elim_list L List LA LL) H M Context Result
    :- reabstract_term List H M Context List'
    ,  isa List (list C) @level
    ,  ((name L, reabstract_dep_type L H M Context L')
        , !; pi z\ locDecl z (list C) => reabstract_type (L z) H M Context (L' z))
    ,  spy(reabstract_term LA H M Context LA')
    ,  ((pi y\ locDecl y C => pi x\ locDecl x (list C) => (name (LL y x), reabstract_dep_term (LL y x) H M Context (LL' y x)))
        , !; pi y\ locDecl y C => pi x\ locDecl x (list C) => pi z\ locDecl z (L x) => 
            reabstract_term (LL y x z) H M Context (LL' y x z))
    ,  Result = (elim_list L' List' LA' LL')
    ,  !
    .

type reabstract_arg mttTerm -> B -> mttTerm -> mttTerm -> context_type -> B -> prop.

reabstract_arg (var_type _ _) A H M Context Result
    :- reabstract_type A H M Context Result
    ,  !
    .
reabstract_arg (var_term _ _) A H M Context Result
    :- reabstract_term A H M Context Result
    ,  !
    .
reabstract_arg (var_dep_type _ _ _) A H M Context Result
    :-  spy((name A, reabstract_dep_type A H M Context A')
        , !; pi x\ locDecl x X_ => reabstract_type (A x) H M Context (A' x))
    ,  Result = A'
    ,  !
    .
reabstract_arg (var_dep_term _ _ _) A H M Context Result
    :- spy((name A, reabstract_dep_term A H M Context A')
        , !; pi x\ locDecl x X_ => reabstract_term (A x) H M Context (A' x))
    ,  Result = A'
    ,  !
    .

type reabstract_lib_call A -> mttTerm -> mttTerm -> context_type -> A -> list mttTerm -> prop.
reabstract_lib_call (lib_app A B) H M Context Result KindTL
    :- spy(reabstract_lib_call A H M Context A' [KindHD|KindTL])
    ,  spy(reabstract_arg KindHD B H M Context B')
    ,  Result = (lib_app A' B')
    ,  !
    .
reabstract_lib_call A _ _ Context A Kind
    :- Context = (context Vars _ LibMap)
    ,  is_extrlib_call A LibMap Hdef
    ,  reverse Vars Vars'
    ,  spy(stylized_type_of Hdef Vars' Kind)
    ,  !
    .

reabstract_type (lib_app A B) H M Context Result
    :- spy(reabstract_lib_call (lib_app A B) H M Context Result _)
    ,  !
    .
reabstract_term (lib_app A B) H M Context Result
    :- spy(reabstract_lib_call (lib_app A B) H M Context Result _)
    ,  !
    .

reabstract_type (# X Y) H M Context Result
    :- reabstract_dep_type X H M Context X'
    ,  reabstract_term Y H M Context Y'
    ,  Result = (# X' Y')
    .
reabstract_term (# X Y) H M Context Result
    :- reabstract_dep_term X H M Context X'
    ,  reabstract_term Y H M Context Y'
    ,  Result = (# X' Y')
    .

reabstract_type A (var_type H _) (var_type M _) _ M
    :- name A
    ,  spy(A = H)
    ,  !
    .
reabstract_type A _ _ _ A.


reabstract_term A (var_term _ H) (var_term _ M) _ M
    :- name A
    ,  spy(A = H)
    ,  !
    .
reabstract_term A _ _ _ A.

type reabstract_dep_term A -> mttTerm -> mttTerm -> context_type -> A -> prop.
reabstract_dep_type A (var_dep_type H _ _) (var_dep_type M _ _) _ M
    :- name A
    ,  A = H
    ,  !
    .
reabstract_dep_type A _ _ _ A.

type reabstract_dep_term A -> mttTerm -> mttTerm -> context_type -> A -> prop.
reabstract_dep_term A (var_dep_term _ H _) (var_dep_term _ M _) _ M
    :- name A
    ,  A = H
    ,  !
    .
reabstract_dep_term A _ _ _ A.


type extractor_dep_lambda mttType -> (mttTerm -> mttType) -> ((mttTerm -> mttTerm) -> mttTerm) -> mttTerm.
type extractor_type_lambda mttKind -> (mttType -> mttTerm) -> mttTerm.
type extractor_dep_type_lambda mttType -> mttKind -> ((mttTerm -> mttType) -> mttTerm) -> mttTerm.

perform_abstractions_ (var_term _ H) TL Context Term Result
    :- spy(of H HType @level)
    ,  spy(extract_type HType XType Context _)
    ,  pi x\ locDecl x XType =>
        ( spy(perform_abstractions TL Context Term Term1)
        , spy(reabstract_term Term1 (var_term _ H) (var_term _ x) Context (Term2 x))
        , spy(Result = (lambda XType Term2)))
    ,  !
    .

perform_abstractions_ (var_dep_term HType H A) TL Context Term Result
    :- spy(of A AType @level)
    ,  spy(isa (H A) (HType A) @level)
    ,  spy((name HType, XType = HType)
        , !; extract_type (HType A) (XType A) Context _)
    ,  pi x\ (of (x A) (XType A) int) =>
        ( spy(perform_abstractions TL Context Term Term1)
        , spy(reabstract_term Term1 (var_dep_term HType H A) (var_dep_term XType x A) Context (Term2 x))
        , spy(Result = (extractor_dep_lambda AType XType Term2)))
    ,  !
    .

perform_abstractions_ (var_type H _) TL Context Term Result
    :- spy(ofType H HKind @level)
    ,  pi Bi\ (isaType Bi HKind int) =>
        ( spy(perform_abstractions TL Context Term Term1)
        , spy(reabstract_term Term1 (var_type H _) (var_type Bi _) Context (Term2 Bi))
        , spy(Result = (extractor_type_lambda HKind Term2)))
    ,  !
    .

perform_abstractions_ (var_dep_type H _ A) TL Context Term Result
    :- spy(of A AType @level)
    ,  spy(ofType (H A) HKind @level)
    ,  pi Bi\ (isaType (Bi A) HKind int) =>
        ( spy(perform_abstractions TL Context Term Term1)
        , spy(reabstract_term Term1 (var_dep_type H _ A) (var_dep_type Bi _ A) Context (Term2 Bi))
        , spy(Result = (extractor_dep_type_lambda AType HKind Term2)))
    ,  !
    .

perform_abstractions [WH|TL] Context Term Result
    :- !
    ,  spy(perform_abstractions_ WH TL Context Term Result)
    ,  !
    .

perform_abstractions [] _ Term Term :- !.

type occurs_var A -> mttTerm -> prop -> prop.
occurs_var A (var_type V _) true :- occurs V A, !.
occurs_var A (var_term _ V) true :- occurs V A, !.
occurs_var A (var_dep_type V _ _) true :- occurs V A, !.
occurs_var A (var_dep_term _ V _) true :- occurs V A, !.
occurs_var _ _ false.

type get_abstraction_list_ A -> list any -> list any -> prop.
get_abstraction_list_ A [H|TL] Result
    :- get_abstraction_list_ A TL Tail
    ,  occurs_var A H IsIn
    ,  ((IsIn = true, Result = [H|Tail]), !; Result = Tail)
    ,  !
    .
get_abstraction_list_ _ [] [].

is_in A [H|_] [A] :- A = H, !.
is_in A [_|TL] R :- is_in A TL R.
is_in _ [] [].

complete_with_types_ H [] List [(var_term _ B)|_] [H]
    :- spy(of B BT @level)
    ,  spy(get_abstraction_list_ BT List BTList)
    ,  spy(is_in H BTList [H])
    ,  !
    .
complete_with_types_ H [] List [(var_dep_term _ B A)|_] [H]
    :- of (B A) (BT A) @level
    ,  get_abstraction_list_ (BT A) List BTList
    ,  is_in H BTList [H]
    ,  !
    .
complete_with_types_ H [] List [_|BTL] Result
    :- complete_with_types_ H [] List BTL Result
    ,  !
    .
complete_with_types_ _ [] _ [] [].

complete_with_types_ H [H] _ _ [H].

complete_with_types [H|TL] List BaseList Result
    :- is_in H BaseList H'
    ,  spy(complete_with_types_ H H' List BaseList HList)
    ,  complete_with_types TL List BaseList TLList
    ,  concat [HList,TLList] Result
    .
complete_with_types [] _ _ [].

complete_with_types_fixpoint List BaseList Result
    :- complete_with_types List List BaseList BaseList'
    ,  ((BaseList = BaseList'
        , Result = BaseList')
        , !; complete_with_types_fixpoint List BaseList' Result)
    .

get_abstraction_list A List Result
    :- get_abstraction_list_ A List BaseList
    ,  spy(complete_with_types_fixpoint List BaseList Result)
    .


extract_collapsing_input_ true Context A [Result]
    :- Context = (context Vars _ _)
    ,  spy(reverse Vars Vars')
    ,  spy(get_abstraction_list A Vars' List)
    ,  spy(perform_abstractions List Context A Result)
    ,  !
    .
extract_collapsing_input_ false _ _ [].

extract_collapsing_input Context Term Term' Result
    :- of Term Type @level, ofType Type Kind @level
    ,  spy(is_informative Kind NeedsExtraction)
    ,  spy(extract_collapsing_input_ NeedsExtraction Context Term Result)
    ,  spy((NeedsExtraction = true, Term' = extractor_star), !; Term' = Term)
    .

%% erase_var_app

type erase_var_app A -> A -> prop.
mode (erase_var_app i o).

erase_var_app (# A B) Result
    :- erase_var_app A A'
    ,  erase_var_app B B'
    ,  Result = (A' B')
    ,  !
    .

erase_var_app (and B C) Result
    :- erase_var_app B B'
    ,  erase_var_app C C'
    ,  Result = (and B' C')
    ,  !
    .

erase_var_app (pair_and B C BB CC) Result 
    :- erase_var_app BB BB'
    ,  erase_var_app CC CC'
    ,  erase_var_app (and B C) (and B' C')
    ,  Result = (pair_and B' C' BB' CC')
    ,  !
    .

erase_var_app (p1_and Pair) Result
    :- erase_var_app Pair Pair'
    ,  Result = (p1_and Pair')
    ,  !
    .

erase_var_app (p2_and Pair) Result
    :- erase_var_app Pair Pair'
    ,  Result = (p2_and Pair')
    ,  !
    .


erase_var_app (exist B C) Result
    :- erase_var_app B B'
    ,  ((name C, C' = C)
        , !; pi b\ locDecl b B => erase_var_app (C b) (C' b))
    ,  Result = (exist B' C')
    ,  !
    .

erase_var_app (pair_exist B C BB CC) Result 
    :- erase_var_app BB BB'
    ,  erase_var_app CC CC'
    ,  erase_var_app (exist B C) (exist B' C')
    ,  Result = (pair_exist B' C' BB' CC')
    ,  !
    .

erase_var_app (elim_exist Pair M MM) Result
    :- erase_var_app Pair Pair'
    ,  isa Pair' (exist B C) @level
    ,  erase_var_app M M'
    ,  ((pi b\ locDecl b B => (name (MM b), MM' = MM))
        , !; pi b\ pi c\ locDecl b B => locDecl c (C b) => erase_var_app (MM b c) (MM' b c))
    ,  Result = (elim_exist Pair' M' MM')
    ,  !
    .


erase_var_app (forall B C) Result
    :- erase_var_app B B'
    ,  ((name C, C' = C)
        , !; pi b\ locDecl b B => erase_var_app (C b) (C' b))
    ,  Result = (forall B' C')
    ,  !
    .

erase_var_app (forall_lam B F) Result
    :- erase_var_app B B'
    ,  ((name F, F' = F)
        , !; pi b\ locDecl b B => erase_var_app (F b) (F' b))
    ,   Result = (forall_lam B' F')
    ,  !
    .

erase_var_app (forall_app Lam X) Result
    :- erase_var_app Lam Lam'
    ,  erase_var_app X X'
    ,  Result = (forall_app Lam' X')
    ,  !
    .


erase_var_app (implies B C) Result
    :- erase_var_app B B'
    ,  erase_var_app C C'
    ,  Result = (implies B' C')
    ,  !
    .

erase_var_app (impl_lam B F) Result
    :- erase_var_app B B'
    ,  ((name F, F' = F)
        , !; pi x\ locDecl x B => erase_var_app (F x) (F' x))
    ,  Result = (impl_lam B' F')
    ,  !
    .

erase_var_app (impl_app Lam X) Result
    :- erase_var_app Lam Lam'
    ,  erase_var_app X X'
    ,  Result = (impl_app Lam' X')
    ,  !
    .


erase_var_app (list C) Result
    :- erase_var_app C C'
    ,  Result = (list C')
    ,  !
    .

erase_var_app (list_empty C) Result
    :- erase_var_app C C'
    ,  Result = (list_empty C')
    ,  !
    .

erase_var_app (list_cons C Head Tail) Result
    :- erase_var_app C C'
    ,  erase_var_app Head Head'
    ,  erase_var_app Tail Tail'
    ,  Result = (list_cons C' Head' Tail')
    ,  !
    .

erase_var_app (elim_list L List LA LL) Result
    :- erase_var_app List List'
    ,  isa List' (list C) @level
    , ((name L, L' = L)
        , !; pi z\ locDecl z (list C) => erase_var_app (L z) (L' z))
    ,  erase_var_app LA LA'
    ,  ((pi y\ locDecl y C => pi x\ locDecl x (list C) => (name (LL y x), LL' = LL))
        , !; pi y\ locDecl y C => pi x\ locDecl x (list C) => pi z\ locDecl z (L x) => 
            erase_var_app (LL y x z) (LL' y x z))
    ,  Result = (elim_list L' List' LA' LL')
    ,  !
    .


erase_var_app (elim_singleton Star C CC) Result 
    :- erase_var_app Star Star'
    ,  ((name C, C' = C)
        , !; pi s\ locDecl s singleton => erase_var_app (C s) (C' s))
    ,  erase_var_app CC CC'
    ,  Result = (elim_singleton Star' C' CC')
    ,  !
    .


erase_var_app (or A B) Result
    :- erase_var_app A A'
    ,  erase_var_app B B'
    ,  Result = (or A' B')
    ,  !
    .

erase_var_app (inl_or A B AA) Result
    :- erase_var_app A A'
    ,  erase_var_app B B'
    ,  erase_var_app AA AA'
    ,  Result = (inl_or A' B' AA')
    ,  !
    .

erase_var_app (inr_or A B BB) Result
    :- erase_var_app A A'
    ,  erase_var_app B B'
    ,  erase_var_app BB BB'
    ,  Result = (inr_or A' B' BB')
    ,  !
    .

erase_var_app (elim_or C W Cl Cr) Result
    :- erase_var_app W W'
    ,  erase_var_app C C'
    ,  isa W' (or L R) @level
    ,  ((name Cl, Cl' = Cl)
        , !; pi l\ locDecl l L => erase_var_app (Cl l) (Cl' l))
    ,  ((name Cr, Cr' = Cr)
        , !; pi r\ locDecl r R => erase_var_app (Cr r) (Cr' r))
    ,  Result = (elim_or C' W' Cl' Cr')
    ,  !
    .


erase_var_app (propEq A AA1 AA2) Result
    :- erase_var_app AA1 AA1'
    ,  erase_var_app AA2 AA2'
    ,  erase_var_app A A'
    ,  Result = (propEq A' AA1' AA2')
    ,  !
    .

erase_var_app (eq A AA) Result
    :- erase_var_app AA AA'
    ,  erase_var_app A A'
    ,  Result = (eq A' AA')
    ,  !
    .


erase_var_app (propId A AA1 AA2) Result
    :- erase_var_app AA1 AA1'
    ,  erase_var_app AA2 AA2'
    ,  erase_var_app A A'
    ,  Result = (propId A' AA1' AA2')
    ,  !
    .

erase_var_app (id A AA) Result
    :- erase_var_app AA AA'
    ,  erase_var_app A A'
    ,  Result = (id A' AA')
    ,  !
    .

erase_var_app (elim_id P C CC) Result
    :- erase_var_app P P'
    ,  isa P (propId A _ _) int
    ,  ((pi x\ locDecl x A => (name (C x), C' = C))
        , !; pi x\ locDecl x A => pi y\ locDecl y A => erase_var_app (C x y) (C' x y))
    ,  ((name CC, CC' = CC)
        , !; pi x\ locDecl x A => erase_var_app (CC x) (CC' x))
    ,  Result = (elim_id P' C' CC')
    ,  !
    .


erase_var_app (setPi B C) Result
    :- erase_var_app B B'
    ,  ((name C, C' = C)
        , !; pi b\ locDecl b B => erase_var_app (C b) (C' b))
    ,  Result = (setPi B' C')
    ,  !
    .

erase_var_app (lambda B F) Result
    :- erase_var_app B B'
    ,  ((name F, F' = F)
        , !; pi b\ locDecl b B => erase_var_app (F b) (F' b))
    ,  Result = (lambda B' F')
    ,  !
    .

erase_var_app (app Lam X) Result
    :- erase_var_app Lam Lam'
    ,  erase_var_app X X'
    ,  Result = (app Lam' X')
    ,  !
    .


erase_var_app (setSigma B C) Result
    :- erase_var_app B B'
    ,  ((name C, C' = C)
        , !; pi b\ locDecl b B => erase_var_app (C b) (C' b))
    ,  Result = (setSigma B' C')
    ,  !
    .

erase_var_app (pair B C BB CC) Result
    :- erase_var_app BB BB'
    ,  erase_var_app CC CC'
    ,  erase_var_app (setSigma B C) (setSigma B' C')
    ,  Result = (pair B' C' BB' CC') 
    ,  !
    .

erase_var_app (p1 Pair) Result
    :- erase_var_app Pair Pair'
    ,  Result = (p1 Pair') 
    ,  !
    .

erase_var_app (p2 Pair) Result
    :- erase_var_app Pair Pair'
    ,  Result = (p2 Pair')
    ,  !
    .

erase_var_app (elim_setSigma Pair M MM) Result
    :- erase_var_app Pair Pair'
    ,  isa Pair' (setSigma B C) @level
    ,  ((name M, M' = M)
        , !; pi p\ locDecl p (setSigma B C) => erase_var_app (M p) (M' p))
    ,  ((pi b\ locDecl b B => (name (MM b), MM' = MM))
        , !; pi b\ pi c\ locDecl b B => locDecl c (C b) => erase_var_app (MM b c) (MM' b c))
    ,  Result = (elim_setSigma Pair' M' MM')
    ,  !
    .


erase_var_app (setSum A B) Result
    :- erase_var_app A A'
    ,  erase_var_app B B'
    ,  Result = (setSum A' B')
    ,  !
    .

erase_var_app (inl A B AA) Result
    :- erase_var_app A A'
    ,  erase_var_app B B'
    ,  erase_var_app AA AA'
    ,  Result = (inl A' B' AA')
    ,  !
    .

erase_var_app (inr A B BB) Result
    :- erase_var_app A A'
    ,  erase_var_app B B'
    ,  erase_var_app BB BB'
    ,  Result = (inr A' B' BB')
    ,  !
    .

erase_var_app (elim_setSum C W Cl Cr) Result
    :- erase_var_app W W'
    ,  isa W' (setSum L R) @level
    ,  ((name C, C' = C)
        , !; pi w\ locDecl w (setSum L R) => erase_var_app (C w) (C' w))
    ,  ((name Cl, Cl' = Cl)
        , !; pi l\ locDecl l L => erase_var_app (Cl l) (Cl' l))
    ,  ((name Cr, Cr' = Cr)
        , !; pi r\ locDecl r R => erase_var_app (Cr r) (Cr' r))
    ,  Result = (elim_setSum C' W' Cl' Cr')
    ,  !
    .

erase_var_app A A.

