% implies

type implies    mttType -> mttType -> mttType.
type impl_lam   mttType -> (mttTerm -> mttTerm) -> mttTerm.
type impl_app   mttTerm -> mttTerm -> mttTerm.


ofType (implies B C) KIND IE
    :- ofType B KIND1 IE
    ,  (pi x\ locDecl x B => ofType C KIND2 IE)
    ,  (pts_prop KIND1 KIND2 KIND)
    .

of (impl_lam B F) (implies B C) IE
    :- spy(pi x\ locDecl x B => of (F x) C IE)
    ,  spy(ofType (implies B C) _ IE)
    .

of (impl_app Lam X) C IE
    :- spy(isa Lam (implies B C) IE)
    ,  spy(isa X B IE)
    .

hstep (impl_app LAM Bb) (F Bb)
    :- hnf LAM (impl_lam _B F)
    .

        
dconv (implies B C) (implies B' C') :- spy(conv B B'), spy(conv C C').
dconv (impl_app F X) (impl_app F' X') :- (conv F F'), (conv X X').
dconv (impl_lam B F) (impl_lam B' F') 
    :- (conv B B')
    ,  pi x\ locDecl x B => conv (F x) (F' x)
    .

interp (implies B C) (forall Bi Ci) 
    :- interp B Bi
    ,  spy(pi x\ pi xi\ interp x xi => locDecl x B => locDecl xi Bi => interp C (Ci xi))
    .

interp (impl_lam B F) (forall_lam Bi Fi) 
    :- of (impl_lam B F) (implies B C_) ext
    ,  spy(interp B Bi)
    ,  spy(pi x\ pi xi\ (locDecl x B, locDecl xi Bi, interp x xi) => interp (F x) (Fi xi))
    .

interp (impl_app F X ) (forall_app Fi Xi) 
    :- spy(interp X Xi)
    ,  spy(interp F Fi)
    .

tau (implies B C) (implies B' C') P
    :- spy(tau B' B FB)
    ,  interp B' Bi'
    ,  spy(macro_tau B B' 
        x\x'\h\xi\xi'\hi\ tau C C' FC') 
    ,  spy(P = w\ impl_lam Bi' x\ FC' (app w (FB x)))
    . 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   ESTRAZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

starify_nonset_ops_type (implies B C) Result
    :- starify_nonset_ops_type B B'
    ,  starify_nonset_ops_type C C'
    ,  Result = (implies B' C')
    ,  !
    .

collapse_type (implies B C) Result
    :- conv B extractor_singleton
    ,  conv C extractor_singleton
    ,  Result = extractor_singleton
    ,  !
    .

extract_set_ops_type (implies B C) Result SetList
    :- extract_set_ops_type B B' BList
    ,  extract_set_ops_type C C' CList
    ,  concat [CList, BList] SetList
    ,  spy(collapse_type (implies B' C') Result)
    ,  !
    .


starify_nonset_ops (impl_lam B F) Result
    :- starify_nonset_ops_type B B'
    ,  pi x\ locDecl x B => starify_nonset_ops (F x) (F' x)
    ,  Result = (impl_lam B' F')
    ,  !
    . 

%% (1 -> 1) -> C (1 -> 1)  ==>  1 -> C 1
collapse_term (impl_lam B F) Result []
    :- isa (impl_lam B F) (implies extractor_singleton extractor_singleton) @level
    ,  Result = extractor_star
    ,  !
    .

extract_set_ops (impl_lam B F) Result SetList
    :- extract_set_ops_type B B' BList
    ,  pi b\ locDecl b B => extract_set_ops (F b) (F' b) FList
    ,  concat [FList, BList] SetList
    ,  spy(collapse_term (impl_lam B' F') Result [])
    ,  !
    .


starify_nonset_ops (impl_app Lam X) Result
    :- starify_nonset_ops Lam Lam'
    ,  starify_nonset_ops X X'
    ,  Result = (impl_app Lam' X')
    ,  !
    .

%% 1  ==>  1  (1)
collapse_term (impl_app Lam X) Result []
    :- isa Lam extractor_singleton @level
    ,  isa X extractor_singleton @level
    ,  Result = extractor_star
    ,  !
    .

%% 1 -> 1  ==>  1  (1)
collapse_term (impl_app Lam X) Result []
    :- isa Lam (implies extractor_singleton extractor_singleton) @level
    ,  isa X extractor_singleton @level
    ,  Result = extractor_star
    ,  !
    .

extract_set_ops (impl_app Lam X) Result SetList
    :- extract_set_ops Lam Lam' LamList
    ,  extract_set_ops X X' XList
    ,  spy(collapse_term (impl_app Lam' X') Result [])
    ,  concat [XList, LamList] SetList
    ,  !
    .

