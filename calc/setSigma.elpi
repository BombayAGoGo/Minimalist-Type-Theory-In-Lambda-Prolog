% for now this is only needed to interpret dependent products types, so no interpretation is needed.

%%-- dependet sums: setSigma
type setSigma mttType -> (mttTerm -> mttType) -> mttType.
type pair mttType ->  (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
type elim_setSigma mttTerm -> (mttTerm -> mttType) -> (mttTerm -> mttTerm -> mttTerm) -> mttTerm.


ofType (setSigma B C) KIND IE 
    :- spy(ofType B KIND1 IE)
    ,  spy(pi b\ locDecl b B => ofType (C b) KIND2 IE)
    ,  (pts_fun KIND1 KIND2 KIND)
    .

of (pair B C BB CC) (setSigma B C) IE 
    :- ofType B _ IE
    ,  ofType (C BB) _ IE
    ,  isa BB B IE
    ,  isa CC (C BB) IE
    .

of (elim_setSigma Pair M MM) (M Pair) IE 
    :- of Pair (setSigma B C) IE
    ,  pi z \ locDecl z (setSigma B C) => ofType (M z) _ IE
    ,  pi x \ pi y \
            locDecl x B => locDecl y (C x) =>  
                isa (MM x y) (M (pair B C x y)) IE
    .

hstep (elim_setSigma Pair M Mm) (Mm Bb Cc) 
    :- hnf Pair (pair B C Bb Cc)
    ,  isa Bb B _
    ,  isa Cc (C Bb) _
    ,  pi z\ locDecl z (setSigma B C) => ofType (M z) _ IE
    ,  pi x \ pi y \
        locDecl x B  => locDecl y (C x) =>  
            isa (Mm x y) (M (pair B C x y))  IE
    .


dconv (setSigma B C) (setSigma B' C') :- (conv B B'), (pi x\ locDecl x B => conv (C x) (C' x)).

dconv (pair B C BB CC) (pair B' C' BB' CC') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    ,  (conv BB BB')                             %% conv BB BB modificato in conv BB BB'
    ,  (conv CC CC')
    .

dconv (elim_setSigma Pair M MM) (elim_setSigma Pair' M' MM') 
    :- (conv Pair Pair')
    ,  (of Pair (setSigma B C) _)
    ,  (pi z\ locDecl z (setSigma B C) => conv (M z) (M' z))
    ,  (pi x\ pi y\  locDecl x B => locDecl y (C x) => conv (MM x y) (MM' x y))
    .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   TRADUZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

interp (setSigma B C) T :-
       spy ( interp B Bi ),
       spy ( macro_interp B (x\xi\_\_\ interp (C x) (Ci xi)) ),
       spy (T = (setSigma Bi Ci) )
       .

interp (pair B C BB CC) T :-
       interp B Bi,
       of BB B' ext,                                     %% B' is the extensional type of BB
       	     						 %% convertible to the type B
       macro_interp B' (x\xi\_\_\ interp (C x) (Ci xi)),  		 	      	  	   
       interp_isa BB B' BBi,   
       interp_isa CC (C BB) CCi,			 
       T = (pair Bi Ci BBi CCi)                          %% Ci parametric on xi, which is the
       	   	       	   				 %% interpretation of an x:B', just like BBi
       .

interp (elim_setSigma Pair M MM) T :-
       print "ELIM_SETSIGMA INTERPRETATION",
       spy (of Pair (setSigma B C) ext),
       spy (interp B Bi),
       spy (interp C Ci),
       spy (interp_isa MM (setPi (setSigma B C) D) MMi),
       spy (interp_isa Pair (setSigma B C) PairI),				%% needs isa? Possible problem with types of function
       	      	   					%% MM being different intensionally
       spy (pi x \ pi y \ pi xi \ pi yi \
            locDecl x B => locDecl y (C x) => locDecl xi Bi =>
	    (interp x xi) => locDecl yi (Ci xi) => (interp y yi) =>  
                (interp (M (pair B C x y)) (Mi xi yi))),
       spy (T = (elim_setSigma PairI                           %% PairI: (setSigma Bi' Ci')
			  (p\ (Mi p))   		  %% function from setSigma Bi' Ci' to the range of MM
			  (w1\w2\ app (elim_setSigma (app (elim_setSigma MMi (_\setPi Bi Type) (x\y\x)) w1) %% T is a setSigma setPi proof
			  	      		     (_\ (setPi (Ci w1) (_\ (Mi  w1 w2))))	 %% not really needed 
						     (x\y\x))
				       w2)))
       .

setoid_eq (setSigma B C) P :-
       print "SETSIGMA SETOID_EQ\n",
       interp B Bi,
       setoid_eq B EquB,
       macro_interp B (x\xi\_\_\ (interp (C x) (Ci xi) ,
       		      		 setoid_eq (C x) (EquC xi))),		   %% Equality over Ci xi
       macro_tau_cov_cov B B (x\x'\h\xi\xi'\hi\ tau (C x) (C x') (FCC xi xi' hi)), %% Cast from type (C x)i to (C x')i with
       		     			       	     	      	     	     	   %% x,x':B
       %% There exists an equality d between p1s and p1z such that
       %% p2z : (C p1z) and the cast to type (C p1z) of p2s:(C p1s) are equal over type (C p1z)
       P = (s\z\
       		exist (EquB (elim_setSigma s (_\Bi) (x\y\ x)) (elim_setSigma z (_\Bi) (x\y\ x)) ) d\
	     	    (
	     		(EquC (elim_setSigma z (_\Bi) (x\y\ x)))
	     		( (FCC (elim_setSigma s (_\Bi) (x\y\ x)) (elim_setSigma z (_\Bi) (x\y\ x)) d)
	     		       ( elim_setSigma s (_\ (Ci (elim_setSigma s (_\Bi) (x\y\ x)))) (x\y\ y)) )
	     		(elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y) )
	             ))
	%%( pi w1 \ print ["ANF: ", B, Bi, C, P, (setSigma B C), EquC, EquB])   %% debug
	.
	
tau (setSigma B C) (setSigma B' C') P :-
    print "SETSIGMA TAU FUNCTION\n",
    spy (interp (setSigma B' C') (setSigma Bi' Ci')),
    spy (tau B B' FB),
    spy (macro_tau_cov_cov B B' (x\x'\h\xi\xi'\hi\tau (C x) (C' x') (FC xi xi' hi))),
    	      	   			       %% given xi: Bi and xi':Bi' and hi intensional proof of their equality
					       %% return function from terms in (C x)int to terms in (C' x')int
					       
    setoid_refl B' Hi,
    %%(interp B' Bi', pi w1 \ print ["CSC: ", B', Bi', Hi, w1, (FB w1), (Hi w1)]),   %% debug
    P = w\ elim_setSigma w (_\ setSigma Bi' Ci')	%% w: (setSigma Bi Ci)
      	   		   (w1\ w2\ pair Bi' Ci'
			   	    	 (FB w1)
					 ( (FC w1 (FB w1) (Hi w1)) w2))    %% Uso di setoid_refl simile a quello in setPi.tau
    .


tau_eq (setSigma B C) (setSigma B' C') P :-
       print "SETSIGMA TAU_EQ FUNCTION\n",
       interp (setSigma B C) (setSigma Bi Ci),
       tau B B' TB,
       tau_eq B B' TeqB,
       setoid_eq B EquB,
       setoid_eq B' EquB',
       setoid_refl B' Hi,
       macro_tau_cov_cov B B' (x\x'\h\xi\xi'\hi\ ((tau (C x) (C' x') (TC xi xi' hi)),
       			      		    	  (tau_eq (C x) (C' x') (TeqC xi xi' hi)),
       			 		    	  (setoid_eq (C x) (EquC xi)),
       			 		    	  (setoid_eq (C' x') (EquC' xi')))),
						  
       macro_tau_cov_cov B B (x1\x2\h\x1i\x2i\hi\ tau (C x1) (C x2) (FCC x1i x2i hi)), %% Cast from type (C x1)i to (C x2)i with
       		     			       	     	      	     	     	       %% both x1 and x2 terms of type B
      
       P = s\z\d\
		pair_exist (EquB'(TB (elim_setSigma s (_\Bi) (x\y\ x))) (TB (elim_setSigma z (_\Bi) (x\y\ x)))) %% type of equality on Bi'
			   (_\ (EquC' (TB (elim_setSigma z (_\Bi) (x\y\ x)))) 		     	    	    %%type of equality on (C' x')i
			       	 ((TC (elim_setSigma z (_\Bi) (x\y\ x)) (FB (elim_setSigma z (_\Bi) (x\y\ x)))
				      (Hi (elim_setSigma z (_\Bi) (x\y\ x))))
				   ((FCC (elim_setSigma s (_\Bi) (x\y\ x))
				       	 (elim_setSigma z (_\Bi) (x\y\ x))
				       	 (elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				       		     	       (elim_setSigma z (_\Bi) (x\y\ x)))
						     (x\y\ x)))
				     ( elim_setSigma s (_\ (Ci (elim_setSigma s (_\Bi) (x\y\ x)))) (x\y\ y))))
			    	 ((TC (elim_setSigma z (_\Bi) (x\y\ x)) (FB (elim_setSigma z (_\Bi) (x\y\ x)))
				      (Hi (elim_setSigma z (_\Bi) (x\y\ x))))
				   ( elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y)))      
			       )
			   (TeqB (elim_setSigma s (_\Bi) (x\y\ x))	%% w1: Equality over Bi'...
				 (elim_setSigma z (_\Bi) (x\y\ x))
				 (elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				 	       	       	 (elim_setSigma z (_\Bi) (x\y\ x)))
				               (x\y\ x)))
			   ((TeqC (elim_setSigma s (_\Bi) (x\y\ x))	%% w2: Equality over (C' TB(p1z))i...
			   	  (TB (elim_setSigma z (_\Bi) (x\y\ x)))
				  (TeqB (elim_setSigma s (_\Bi) (x\y\ x))  
				  	(elim_setSigma z (_\Bi) (x\y\ x))
				 	(elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				       		     	        (elim_setSigma z (_\Bi) (x\y\ x)))
						     (x\y\ x))))
			      ((FCC (elim_setSigma s (_\Bi) (x\y\ x)) (elim_setSigma z (_\Bi) (x\y\ x))
			    	  (elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				  	      	    	  (elim_setSigma z (_\Bi) (x\y\ x)))
						(x\y\ x)))
			         ( elim_setSigma s (_\ (Ci (elim_setSigma s (_\Bi) (x\y\ x)))) (x\y\ y)))       
			      ( elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y)) 	       
			      ( elim_exist d ((EquC (elim_setSigma z (_\Bi) (x\y\ x)))
			      		       	  ((FCC (elim_setSigma s (_\Bi) (x\y\ x)) (elim_setSigma z (_\Bi) (x\y\ x))
			    	  		      	    (elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				  	      	      	    		      	    (elim_setSigma z (_\Bi) (x\y\ x)))
						      	    	          (x\y\ x)))
							(elim_setSigma s (_\ (Ci (elim_setSigma s (_\Bi) (x\y\ x)))) (x\y\ y)))       
			    			(elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y)))
			    (x\y\ y)))       
       .

setoid_refl (setSigma B C) H :-
     print "SETSIGMA SETOID_REFL FUNCTION\n",
     interp (setSigma B C) (setSigma Bi Ci),
     setoid_eq B EquB,
     setoid_refl B HB,
     macro_interp B (x\xi\_\_\ ( (setoid_eq (C x) (EquC xi)),
     		    	       	 (setoid_refl (C x) (HC xi)) )),
     H = z\ pair_exist (EquB (elim_setSigma z (_\Bi) (x\y\ x)) (elim_setSigma z (_\Bi) (x\y\ x)) )
       	    	       (_\ ((EquC (elim_setSigma z (_\Bi) (x\y\ x)))
		       	   	  	(elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y))
		       	   	  	(elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y))))
			(HB (elim_setSigma z (_\Bi) (x\y\ x)))
			((HC (elim_setSigma z (_\Bi) (x\y\ x))) (elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y)))

    	%% checks?
     .

setoid_symm (setSigma B C) H :-
      print "SETSIGMA SETOID_SYMM FUNCTION",
      interp (setSigma B C) (setSigma Bi Ci),
      setoid_eq B EquB,
      setoid_symm B SB,
      macro_interp B (x\xi\_\_\ ( (setoid_eq (C x) (EquC xi)),
      		     		  (setoid_symm (C x) (SC xi)) )),
      macro_tau_cov_cov B B (x1\x2\h\x1i\x2i\hi\ tau (C x1) (C x2) (FCC x1i x2i hi)),
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Possible workaround for determining the type of the resulting equality? %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      macro_tau_cov_cov B B (x1\x2\h\x1i\x2i\hi\ ( (tau (C x1) (C x2) (FCC x1i x2i hi)),
						   (setoid_symm (C x1) (SC x1i)),
						   (setoid_eq (C x1) (EquC x1i)),
						   (interp (C x1) (Ci x1i)),
						   (pi y1i\ pi y2i\ pi d\
						      locDecl y1i (Ci x1i) =>
						      locDecl y2i (Ci x2i) =>
						      locDecl d ((EquC x2i) ((FCC x1i x2i hi) y1i) y2i) => 
						      (of ((SC x2i) ((FCC x1i x2i hi) y1i)  %% (SC x2i) because d used EquC x2i
						   	   	    y2i	      	      	    %% the result of this recursive call could
								    d)			    %% is not necessarily an equality in (C x2)?
							  (T x1i y1i y2i d) IE)))),
								      %% This would be used as the dependent
								      %% type of the pair_exist, leaving the type of the
								      %% equality to be determined by the recursive call
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      H = s\z\d\
      	  pair_exist (EquB (elim_setSigma z (_\Bi) (x\y\ x)) (elim_setSigma s (_\Bi) (x\y\ x))) %% Type of equality over Bi between p1z
      	  	 	    	  		   	  	    		     	    	%% and p2s.
      	  	     ( _\((EquC (elim_setSigma z (_\Bi) (x\y\ x)))                          %% C: Type of equality over (C p1z)i between 
		       	     ( (elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) %% p2z and the cast to (C p1z)i of p2s
			       		      	(x\y\ y)))
		       	     ((FCC (elim_setSigma s (_\Bi) (x\y\ x))			   	      
			     	   (elim_setSigma z (_\Bi) (x\y\ x))				      
				   (elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				  	       	 (elim_setSigma z (_\Bi) (x\y\ x)))
				       		 (x\y\ x)))
			     	 (elim_setSigma s (_\ (Ci (elim_setSigma s (_\Bi) (x\y\ x)))) (x\y\ y)))
			     ) )
		     (SB (elim_setSigma s (_\Bi) (x\y\ x))			%% First element, obtained by induction on B 
		     	 (elim_setSigma z (_\Bi) (x\y\ x))
		     	 (elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				  	     (elim_setSigma z (_\Bi) (x\y\ x)))
				       (x\y\ x)))
		     ((SC (elim_setSigma z (_\Bi) (x\y\ x)))			%% Second element, obtained by induction on (C p1z)
		     	  ((FCC (elim_setSigma s (_\Bi) (x\y\ x))		%% because of this, H will produce an equality over 
			  	(elim_setSigma z (_\Bi) (x\y\ x))		%% (C p1z)i between z and s, possibly causing problems?
			  	(elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				  	      	    (elim_setSigma z (_\Bi) (x\y\ x)))
				              (x\y\ x)))
			      (elim_setSigma s (_\ (Ci (elim_setSigma s (_\Bi) (x\y\ x)))) (x\y\ y)))
			  ((elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y)))
			  (( elim_exist d ((EquC (elim_setSigma z (_\Bi) (x\y\ x)))
			      		       	  ((FCC (elim_setSigma s (_\Bi) (x\y\ x)) (elim_setSigma z (_\Bi) (x\y\ x))
			    	  		      	    (elim_exist d (EquB (elim_setSigma s (_\Bi) (x\y\ x))
				  	      	      	    		      	    (elim_setSigma z (_\Bi) (x\y\ x)))
						      	    	          (x\y\ x)))
							(elim_setSigma s (_\ (Ci (elim_setSigma s (_\Bi) (x\y\ x)))) (x\y\ y)))       
			    			(elim_setSigma z (_\ (Ci (elim_setSigma z (_\Bi) (x\y\ x)))) (x\y\ y)))
			    (x\y\ y))))
	%% checks?
      .



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                UTILITY                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type p1, p2  A->A.	%% mttTerm->mttTerm? Needed for both ext and int pairs...
     	     		%% Currently unused
p1 Pair R :-
   of Pair (setSigma B C) IE,
   R = (elim_setSigma Pair (_\B) (x\y\ x) )
   .

p2 Pair R :-
   of Pair (setSigma B C) IE,
   p1 Pair R1,
   R = (elim_setSigma Pair (_\ (C R1)) (x\y\ y) )
   .