% for now this is only needed to interpret dependent products types, so no interpretation is needed.

%%-- dependet sums: setSigma
type setSigma mttType -> (mttTerm -> mttType) -> mttType.
type pair mttType ->  (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
type elim_setSigma mttTerm -> (mttTerm -> mttType) -> (mttTerm -> mttTerm -> mttTerm) -> mttTerm.


ofType (setSigma B C) KIND IE 
    :- spy(ofType B KIND1 IE)
    ,  spy(pi b\ locDecl b B => ofType (C b) KIND2 IE)
    ,  (pts_fun KIND1 KIND2 KIND)
    .

of (pair B C BB CC) (setSigma B C) IE 
    :- ofType B _ IE
    ,  ofType (C BB) _ IE
    ,  isa BB B IE
    ,  isa CC (C BB) IE
    .

of (elim_setSigma Pair M MM) (M Pair) IE 
    :- spy (of Pair (setSigma B C) IE)
    ,  spy (pi z \ locDecl z (setSigma B C) => ofType (M z) _ IE)
    ,  spy (pi x \ pi y \
            locDecl x B => locDecl y (C x) =>  
                isa (MM x y) (M (pair B C x y)) IE )
    .

hstep (elim_setSigma Pair M Mm) (Mm Bb Cc) 
    :- spy(hnf Pair (pair B C Bb Cc))
    ,  spy(isa Bb B _)
    ,  spy(isa Cc (C Bb) _)
    ,  spy(pi z\ locDecl z (setSigma B C) => ofType (M z) _ IE)
    ,  spy(pi x \ pi y \
        locDecl x B  => locDecl y (C x) =>  
            isa (Mm x y) (M (pair B C x y))  IE)
    .


dconv (setSigma B C) (setSigma B' C') :- (conv B B'), (pi x\ locDecl x B => conv (C x) (C' x)).

dconv (pair B C BB CC) (pair B' C' BB' CC') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    ,  (conv BB BB')                             %% conv BB BB modificato in conv BB BB'
    ,  (conv CC CC')
    .

dconv (elim_setSigma Pair M MM) (elim_setSigma Pair' M' MM') 
    :- (conv Pair Pair')
    ,  (of Pair (setSigma B C) _)
    ,  (pi z\ locDecl z (setSigma B C) => conv (M z) (M' z))
    ,  (pi x\ pi y\  locDecl x B => locDecl y (C x) => conv (MM x y) (MM' x y))
    .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   TRADUZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

interp (setSigma B C) T :-
       interp B Bi,
       macro_interp B (x\xi\_\_\ interp (C x) (Ci xi)),
       T = (setSigma Bi Ci)
       .

interp (pair B C BB CC) T :-
       interp B Bi,
       of BB B' ext,                                      %% B' is the extensional type of BB
       	     						 %% convertible to the type B
       macro_interp B' (x\xi\_\_\ interp (C x) (Ci xi)),  		 	      	  	   
       interp_isa BB B' BBi,   
       interp_isa CC (C BB) CCi,			 
       T = (pair Bi Ci BBi CCi)                          %% Ci parametric on xi, which is the
       	   	       	   				 %% interpretation of x:B', like BBi
       .

setoid_eq (setSigma B C) P :-
       interp B Bi,
       setoid_eq B EquB,
       macro_interp B (x\xi\_\_\ (interp (C x) (Ci xi) ,
       		      		 setoid_eq (C x) (EquC xi))),		   %% Equality over Ci xi
       macro_tau B B (x\x'\h\xi\xi'\hi\ tau (C x) (C x') (FCC xi xi' hi)), %% Cast from type (C x) to (C x') with
       		     			       	     	      	     	   %% x,x':B
       P = (s\z\
	 %% using the projection macros this way seems to create problems for ofType function
              %p1 s S1,  	      %% S1 = elim_setSigma s (_\B) (x\y\ x)
	      %p1 z Z1,  	      %% Z1 = elim_setSigma z (_\B) (x\y\ x)
	      %p2 s S2,  	      %% S2 = elim_setSigma s (_\ (C (elim_setSigma s (_\B) (x\y\ x)))) (x\y\ y)
	      %p2 z Z2,		      %% Z2 = elim_setSigma z (_\ (C (elim_setSigma z (_\B) (x\y\ x)))) (x\y\ y)
	      %exist (EquB S1 Z1) d\		%% there exists an equality d between S1 and Z1 such that
	      %	    	   EquC Z1		%% Z2:(C Z1) and the cast to type (C Z1) of S2:(C S1) 
	      %	    	   ( (FCC S1 Z1 d) S2)   %% are equal over type (C Z1)
	      %		   Z2)
	 %% this is the verbose (but working) solution		   
	 exist (EquB (elim_setSigma s (_\B) (x\y\ x)) (elim_setSigma z (_\B) (x\y\ x)) ) d\
	     	    (
	     		(EquC (elim_setSigma z (_\B) (x\y\ x)))
	     		( (FCC (elim_setSigma s (_\B) (x\y\ x)) (elim_setSigma z (_\B) (x\y\ x)) d)
	     		       elim_setSigma s (_\ (C (elim_setSigma s (_\B) (x\y\ x)))) (x\y\ y))
	     		(elim_setSigma z (_\ (C (elim_setSigma z (_\B) (x\y\ x)))) (x\y\ y))
	             ))
	.

tau (setSigma B C) (setSigma B' C') P :-
    print "||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n",
    print "||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n",
    interp (setSigma B' C') (setSigma Bi' Ci'),
    tau B B' FB,
    macro_tau B B' (x\x'\h\xi\xi'\hi\tau (C x) (C' x') (FC xi xi' hi)),
    	      	   			       %% given xi: Bi and xi':Bi' and hi intensional proof of their equality
					       %% return function from terms in (C x)int to terms in (C' x')int
					       
    macro_tau B B' (x\x'\h\xi\xi'\hi\ tau_proof_eq x x' B (IntEqu xi xi')), %% dovrebbe valere (conv B B')
    	      	   		      		     	  	     	    %% a questa funzione passerÃ² come parametri
									    %% w1 e (FB w1) che sono necessariamente ext
									    %% uguali. Ho bisogno di parametri aggiuntivi?
    P = (w\ elim_setSigma w (_\ setSigma Bi' Ci')	%% w: (setSigma Bi Ci)
      	   		   (w1\ w2\ pair Bi' Ci'
			   	    	 (FB w1)
					 ( (FC w1 (FB w1) (IntEqu w1 (FB w1)))
					       w2)))
    .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                UTILITY                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type p1, p2  A->A.	%% mttTerm->mttTerm? Needed for both ext and int pairs...
     	     		%% Currently unused
p1 Pair R :-
   of Pair (setSigma B C) IE,
   R = (elim_setSigma Pair (_\B) (x\y\ x) )
   .

p2 Pair R :-
   of Pair (setSigma B C) IE,
   p1 Pair R1,
   R = (elim_setSigma Pair (_\ (C R1)) (x\y\ y) )
   .