% for now this is only needed to interpret dependent products types, so no interpretation is needed.

%%-- dependet sums: setSigma
type setSigma mttType -> (mttTerm -> mttType) -> mttType.
type pair mttType ->  (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
type elim_setSigma mttTerm -> (mttTerm -> mttType) -> (mttTerm -> mttTerm -> mttTerm) -> mttTerm.


ofType (setSigma B C) KIND IE 
    :- spy(ofType B KIND1 IE)
    ,  spy(pi b\ locDecl b B => ofType (C b) KIND2 IE)
    ,  (pts_fun KIND1 KIND2 KIND)
    .

of (pair B C BB CC) (setSigma B C) IE 
    :- spy(ofType B _ IE)
    ,  spy(ofType (C BB) _ IE)
    ,  spy(isa BB B IE)
    ,  spy(isa CC (C BB) IE)
    .

of (elim_setSigma Pair M MM) (M Pair) IE 
    :- spy (isa Pair (setSigma B C) IE)
    ,  pi z \ locDecl z (setSigma B C) => spy (ofType (M z) _ IE)
    ,  pi x \ pi y \
            locDecl x B => locDecl y (C x) =>  
                spy (isa (MM x y) (M (pair B C x y)) IE)
    .

hstep (elim_setSigma Pair M Mm) (Mm Bb Cc) 
    :- hnf Pair (pair B C Bb Cc)
    ,  isa Bb B _
    ,  isa Cc (C Bb) _
    ,  pi z\ locDecl z (setSigma B C) => ofType (M z) _ IE
    ,  pi x \ pi y \
        locDecl x B  => locDecl y (C x) =>  
            isa (Mm x y) (M (pair B C x y))  IE
    .


dconv (setSigma B C) (setSigma B' C') :- (conv B B'), (pi x\ locDecl x B => conv (C x) (C' x)).

dconv (pair B C BB CC) (pair B' C' BB' CC') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    ,  (conv BB BB')                             %% conv BB BB modificato in conv BB BB'
    ,  (conv CC CC')
    .

dconv (elim_setSigma Pair M MM) (elim_setSigma Pair' M' MM') 
    :- (conv Pair Pair')
    ,  (of Pair (setSigma B C) _)
    ,  (pi z\ locDecl z (setSigma B C) => conv (M z) (M' z))
    ,  (pi x\ pi y\  locDecl x B => locDecl y (C x) => conv (MM x y) (MM' x y))
    .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   TRADUZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


interp (setSigma B C) T :-
       spy ( interp B Bi ),
       spy ( macro_interp B (x\xi\_\_\ interp (C x) (Ci xi)) ),
       spy (T = (setSigma Bi Ci) )
       .

interp (pair B C BB CC) T :-
       interp B Bi,
       of BB B' ext,                                     %% B' is the extensional type of BB
       	     						 %% convertible to the type B
       macro_interp B' (x\xi\_\_\ interp (C x) (Ci xi)),  		 	      	  	   
       interp_isa BB B' BBi,   
       interp_isa CC (C BB) CCi,			 
       T = (pair Bi Ci BBi CCi)                          %% Ci parametric on xi, which is the
       	   	       	   				 %% interpretation of an x:B', just like BBi
       .

/* interp (elim_setSigma Pair M MM) T :-
       print "ELIM_SETSIGMA INTERPRETATION",
       spy (of Pair (setSigma B C) ext),
       spy (interp B Bi),
       spy (interp C Ci),
       spy (interp_isa MM (setPi (setSigma B C) D) MMi),
       spy (interp_isa Pair (setSigma B C) PairI),				%% needs isa? Possible problem with types of function
       	      	   					%% MM being different intensionally
       spy (pi x \ pi y \ pi xi \ pi yi \
            locDecl x B => locDecl y (C x) => locDecl xi Bi =>
	    (interp x xi) => locDecl yi (Ci xi) => (interp y yi) =>  
                (interp (M (pair B C x y)) (Mi xi yi))),
       spy (T = (elim_setSigma PairI                           %% PairI: (setSigma Bi' Ci')
			  (p\ (Mi p))   		  %% function from setSigma Bi' Ci' to the range of MM
			  (w1\w2\ app (elim_setSigma (app (elim_setSigma MMi (_\setPi Bi Type) (x\y\x)) w1) %% T is a setSigma setPi proof
			  	      		     (_\ (setPi (Ci w1) (_\ (Mi  w1 w2))))	 %% not really needed 
						     (x\y\x))
				       w2)))
       .
*/

type setSigma_setoid mttType -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
type setSigma_setoidDep mttType -> (mttTerm -> mttType) -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm -> mttTerm. 

setoid_eq (setSigma B C) P :-
       print "SETSIGMA SETOID_EQ\n",
       interp B Bi,
       setoid_eq B EquB,
       macro_interp B (x\xi\_\_\ (interp (C x) (Ci xi) ,
       		      		 setoid_eq (C x) (EquC xi))),			   %% Equality over Ci xi
       macro_tau_cov_cov B B (x\x'\h\xi\xi'\hi\ tau (C x) (C x') (FCC xi xi' hi)), %% Cast from type (C x)i to (C x')i with
       		     			       	     	      	     	     	   %% x,x':B
       EquB' = (lambda Bi x \ lambda Bi y \ encode (EquB x y)),
       EquC' = (lambda Bi x \ lambda (Ci x) a \ lambda (Ci x) b \ encode (EquC x a b)),
       Cast = (lambda Bi x \ lambda Bi x' \ lambda (EquB x x') d \ lambda (Ci x) a \ FCC x x' d a),
       P = (s\z\
             decode (app (app (app (setoid_rel (setSigma Bi Ci)) (app (setSigma_setoid Bi Ci EquB' EquC') Cast)) s) z)).

type setSigmaLib list libraryEntry -> prop.

type new_interp_type mttType -> mttTerm -> prop.
type new_interp_dep_type mttType -> (mttTerm -> mttType) -> mttTerm -> prop.
type singleton_setoid mttTerm.
type singleton_setoidDep mttType -> mttTerm.

new_interp_type singleton singleton_setoid.

new_interp_type (setSigma B C) O :-
   spy (interp B Bi),
   spy (macro_interp B (x\xi\_\_\ interp (C x) (Ci xi))),
   spy (new_interp_type B Bs),
   spy (new_interp_dep_type B C Cs),
   O = setSigma_setoid Bi Ci Bs Cs.

new_interp_dep_type B (x \ singleton) O :-
   interp B Bi,
   O = singleton_setoidDep Bi.

new_interp_dep_type A (x \ setSigma (B x) (C x)) O :-
   spy (interp A Ai),
   macro_interp A (x\xi\_\_\ interp (B x) (Bi xi)),
   (pi w \ locDecl w (setSigma Ai Bi) => (p1 w (P1 w), p2 w (P2 w))),
   spy(macro_interp (setSigma A B) (x\xi\_\_\ interp (C (P1 x) (P2 x)) (Ci xi))),
   O = setSigma_setoidDep Ai Bi Ci.

singletonLib L :-
 L =
 [ (locDefL singleton_setoid (setoid singleton)
    (pair
      (setPi singleton x \ setPi singleton y \ propS) 
      (rel \ forall singleton x \ decode (app (app rel x) x))
      (lambda singleton x \ lambda singleton y \ encode (propId singleton x y))
      (forall_lam singleton x \ id singleton x)
    ))
 , (univPi Bi \
    locDefL (singleton_setoidDep Bi) (setoidDep Bi x \ singleton)
    (lambda (setoid Bi) bS \
      pair
        (setPi Bi _\ setoid singleton)
        (_ \ setPi Bi x \ setPi Bi x' \ setPi (decode (app (app (app (setoid_rel Bi) bS) x) x')) _ \ setPi singleton _ \ singleton)
        (lambda Bi x \ singleton_setoid)
        (lambda Bi x \ lambda Bi x' \ lambda (decode (app (app (app (setoid_rel Bi) bS) x) x')) _ \ lambda singleton y \ y)
    ))
 ].

setSigmaLib L :-
 (pi Bi \ pi Ci \ pi w \ locDecl w (setSigma Bi Ci) => (p1 w (P1 Bi Ci w), p2 w (P2 Bi Ci w))),
 L =
 [% setSigma_setoid
  (univPi Bi \
    univDepPi Bi Ci \
     univPiT (setoid Bi) bS \
      univPiT (setoidDep Bi Ci) cS \
       hyp (pi x\ isa x Bi int 
        => pi y \ isa y (Ci x) int
        => conv
           y (app (app (app (app (app (app (setoidDepCast Bi Ci) cS) bS) x) x) (forall_app (app (setoid_reflL Bi) bS) x)) y) 
           )
           (pi x\ locDecl x Bi 
        => pi y \ locDecl y (Ci x) 
        => spy (conv
           y (app (app (app (app (app (app (setoidDepCast Bi Ci) cS) bS) x) x) (forall_app (app (setoid_reflL Bi) bS) x)) y) 
           ))
        ((locDefL (setSigma_setoid Bi Ci bS cS) (setoid (setSigma Bi Ci))
          (pair
             (setPi (setSigma Bi Ci) _ \ setPi (setSigma Bi Ci) _ \ propS)
             (rel \ forall (setSigma Bi Ci) x \ decode (app (app rel x) x))
             % the setoid relation
            (lambda (setSigma Bi Ci) s \
              lambda (setSigma Bi Ci) z \
               encode (exist (decode (app (app (app (setoid_rel Bi) bS) (P1 Bi Ci s)) (P1 Bi Ci z))) d\
                    decode (app (app (app (setoid_rel (Ci (P1 Bi Ci z))) (app
                    	     	       	    		    	(app (app (setoidDepCarrier Bi Ci) cS) bS ) (P1 Bi Ci z)))
                               (app (app (app (app (app (app (setoidDepCast Bi Ci) cS) bS) (P1 Bi Ci s)) (P1 Bi Ci z)) d) (P2 Bi Ci s)))
                               (P2 Bi Ci z))))
             % proof of reflexivity
            (forall_lam (setSigma Bi Ci) x \
              pair_exist
               (decode (app (app (app (setoid_rel Bi) bS) (P1 Bi Ci x)) (P1 Bi Ci x)))
               (d \ decode (app (app 
               (app (setoid_rel (Ci (P1 Bi Ci x)))
                 (app (app (app (setoidDepCarrier Bi Ci) cS) bS ) (P1 Bi Ci x)))
                 (app (app (app (app (app (app (setoidDepCast Bi Ci) cS) bS) (P1 Bi Ci x)) (P1 Bi Ci x)) d) (P2 Bi Ci x)))                  
                   (P2 Bi Ci x)))
               (forall_app (app (setoid_reflL Bi) bS) (P1 Bi Ci x))
               (forall_app (app (setoid_reflL (Ci (P1 Bi Ci x))) (app (app (app (setoidDepCarrier Bi Ci) cS) bS ) (P1 Bi Ci x))) (P2 Bi Ci x))))))),
 % setSigma_setoidDep
 (univPi Ai \
   univDepPi Ai Bi \
    univDepPi (setSigma Ai Bi) Ci \
     univPiT (setoid Ai) aS \
      univPiT (setoidDep Ai Bi) bS \
       univPiT (setoidDep (setSigma Ai Bi) Ci) cS \
        locDefL (setSigma_setoidDep Ai Bi Ci aS bS cS) (setoidDep Ai (a \ setSigma (Bi a) (b \ Ci (pair Ai Bi a b))))
         (lambda (setoid Ai) aS \
           pair
            (setPi Ai a\ setoid (setSigma (Bi a) (b \ Ci (pair Ai Bi a b))))
            (_ \
              setPi Ai a \ setPi Ai a' \
               setPi (decode (app (app (app (setoid_rel Ai) aS) a) a')) _ \
                setPi (setSigma (Bi a) (b \ Ci (pair Ai Bi a b))) _ \
                 setSigma (Bi a') (b \ Ci (pair Ai Bi a' b)))
            (fixMe "<<< setSigma_setoid_dep_one" _)
            (fixMe "<<< setSigma_setoid_dep_two" _)
 ))
].
	
tau (setSigma B C) (setSigma B' C') P :-
    print "SETSIGMA TAU FUNCTION\n",
    interp (setSigma B' C') (setSigma Bi' Ci'),
    spy (tau B B' FB),
    spy (macro_tau_cov_cov B B' (x\x'\h\xi\xi'\hi\tau (C x) (C' x') (FC xi xi' hi))),
    	      	   			       %% given xi: Bi and xi':Bi' and hi intensional proof of their equality
					       %% return function from terms in (C x)int to terms in (C' x')int
					       
    setoid_refl B' Hi,
    %%(interp B' Bi', pi w1 \ print ["CSC: ", B', Bi', Hi, w1, (FB w1), (Hi w1)]),   %% debug
    P = w\ elim_setSigma w (_\ setSigma Bi' Ci')	%% w: (setSigma Bi Ci)
      	   		   (w1\ w2\ pair Bi' Ci'
			   	    	 (FB w1)
					 ( (FC w1 (FB w1) (Hi w1)) w2))    %% Uso di setoid_refl simile a quello in setPi.tau
    .


tau_eq (setSigma B C) (setSigma B' C') P :-
       print "SETSIGMA TAU_EQ FUNCTION\n",
       interp (setSigma B C) (setSigma Bi Ci),
       tau B B' TB,
       tau_eq B B' TeqB,
       setoid_eq B EquB,
       setoid_eq B' EquB',
       setoid_refl B' Hi,
       macro_tau_cov_cov B B' (x\x'\h\xi\xi'\hi\ ((tau (C x) (C' x') (TC xi xi' hi)),
       			      		    	  (tau_eq (C x) (C' x') (TeqC xi xi' hi)),
       			 		    	  (setoid_eq (C x) (EquC xi)),
       			 		    	  (setoid_eq (C' x') (EquC' xi')))),
						  
       macro_tau_cov_cov B B (x1\x2\h\x1i\x2i\hi\ tau (C x1) (C x2) (FCC x1i x2i hi)), %% Cast from type (C x1)i to (C x2)i with
       		     			       	     	      	     	     	       %% both x1 and x2 terms of type B
       pi w\ (locDecl w (setSigma Bi Ci)) => ( p1 w (P1 w),
       	  	       	      	     	       p2 w (P2 w)),
      
       P = s\z\d\
		pair_exist (EquB'(TB (P1 s)) (TB (P1 z)))			       %% type of equality on Bi'
			   (_\ (EquC' (TB (P1 z))) 		     	    	       %% type of equality on (C' x')i
			       	 ((TC (P1 z) (FB (P1 z)) (Hi (P1 z)))
				   ((FCC (P1 s) (P1 z) (elim_exist d (EquB (P1 s) (P1 z))(x\y\ x)))
				      (P2 s)))
			    	 ((TC (P1 z) (FB (P1 z)) (Hi (P1 z)))
				   (P2 z))      
			       )
			   (TeqB (P1 s)							%% Equality over Bi'...
				 (P1 z)
				 (elim_exist d (EquB (P1 s) (P1 z)) (x\y\ x)))
			   ((TeqC (P1 s)						%% Equality over (C' TB(p1z))i...
			   	  (TB (P1 z))
				  (TeqB (P1 s)  
				  	(P1 z)
				 	(elim_exist d (EquB (P1 s) (P1 z)) (x\y\ x))))
			      ((FCC (P1 s) (P1 z) (elim_exist d (EquB (P1 s) (P1 z)) (x\y\ x)))
			         (P2 s))       
			      (P2 z) 	       
			      ( elim_exist d ((EquC (P1 z))
			      		       	    ((FCC (P1 s) (P1 z) (elim_exist d (EquB (P1 s) (P1 z)) (x\y\ x)))
						       (P2 s))       
			    		            (P2 z))
			    		     (x\y\ y)))       
       .

setoid_refl (setSigma B C) H :-
     print "SETSIGMA SETOID_REFL FUNCTION\n",
     interp (setSigma B C) (setSigma Bi Ci),
     setoid_eq B EquB,
     setoid_refl B HB,
     macro_interp B (x\xi\_\_\ ( (setoid_eq (C x) (EquC xi)),
     		    	       	 (setoid_refl (C x) (HC xi)) )),
     pi w\ (locDecl w (setSigma Bi Ci)) => ( p1 w (P1 w),
       	  	       	      	     	       p2 w (P2 w)),
     H = z\ pair_exist (EquB (P1 z) (P1 z) )
       	    	       (_\ (EquC (P1 z)) (P2 z) (P2 z))
		       (HB (P1 z))
		       ((HC (P1 z)) (P2 z))
    	%% checks?
     .

setoid_symm (setSigma B C) H :-
      print "SETSIGMA SETOID_SYMM FUNCTION",
      interp (setSigma B C) (setSigma Bi Ci),
      setoid_eq B EquB,
      setoid_symm B SB,
      macro_interp B (x\xi\_\_\ ( (setoid_eq (C x) (EquC xi)),
      		     		  (setoid_symm (C x) (SC xi)) )),
      macro_tau_cov_cov B B (x1\x2\h\x1i\x2i\hi\ tau (C x1) (C x2) (FCC x1i x2i hi)),
      pi w\ (locDecl w (setSigma Bi Ci)) => ( p1 w (P1 w),
       	  	       	      	     	       p2 w (P2 w)),
      H = s\z\d\
      	  pair_exist (EquB (P1 z) (P1 s))					            %% Type of equality over Bi of p1z p1s
      	  	     ( _\ (EquC (P1 z))                         			    %% Type of equality over (C p1z)i between 
		       	     (P2 z)  				   			    %% p2z and the cast to (C p1z)i of p2s
		       	     ((FCC (P1 s) (P1 z) (elim_exist d (EquB (P1 s) (P1 z)) (x\y\ x)))
			     	 (P2 s)))
		     (SB (P1 s)							%% First element, obtained by induction on B 
		     	 (P1 z)
		     	 (elim_exist d (EquB (P1 s) (P1 z)) (x\y\ x)))
		     ((SC (P1 z))      	     	    				%% Second element, obtained by induction on (C p1z)
		     	  ((FCC (P1 s)						%% because of this, H will produce an equality over 
			  	(P1 z)						%% (C p1z)i between z and s, possibly causing problems?
			  	(elim_exist d (EquB (P1 s) (P1 z)) (x\y\ x)))
			      (P2 s))
			  (P2 z)
			  (( elim_exist d ((EquC (P1 z))
			      		       	 ((FCC (P1 s) (P1 z)
			    	  		      	(elim_exist d (EquB (P1 s) (P1 z)) (x\y\ x)))
						    (P2 s))       
			    			 (P2 z))
					  (x\y\ y))))
	%% checks?
      .



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                UTILITY                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type p1, p2  A->A.	%% mttTerm->mttTerm? Needed for both ext and int pairs...
     	     		%% Currently unused
p1 Pair R :-
   isa Pair (setSigma B C_) IE_,
   R = (elim_setSigma Pair (_\B) (x\y\ x) )
   .

p2 Pair R :-
   isa Pair (setSigma B C) IE,
   spy (pi Pair \ of Pair (setSigma B C) IE => p1 Pair (R1 Pair)),
   R = (elim_setSigma Pair (x\ C (R1 x)) (x\y\ y))
.
