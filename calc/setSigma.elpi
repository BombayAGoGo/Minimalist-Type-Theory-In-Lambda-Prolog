% for now this is only needed to interpret dependent products types, so no interpretation is needed.

%%-- dependet sums: setSigma
type setSigma mttType -> (mttTerm -> mttType) -> mttType.
type pair mttType ->  (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
type elim_setSigma mttTerm -> (mttTerm -> mttType) -> (mttTerm -> mttTerm -> mttTerm) -> mttTerm.


ofType (setSigma B C) KIND IE 
    :- spy(ofType B KIND1 IE)
    ,  spy(pi b\ locDecl b B => ofType (C b) KIND2 IE)
    ,  (pts_fun KIND1 KIND2 KIND)
    .

of (pair B C BB CC) (setSigma B C) IE 
    :- ofType B _ IE
    ,  ofType (C BB) _ IE
    ,  isa BB B IE
    ,  isa CC (C BB) IE
    .

of (elim_setSigma Pair M MM) (M Pair) IE 
    :- spy (of Pair (setSigma B C) IE)
    ,  spy (pi z \ locDecl z (setSigma B C) => ofType (M z) _ IE)
    ,  spy (pi x \ pi y \
            locDecl x B => locDecl y (C x) =>  
                isa (MM x y) (M (pair B C x y)) IE )
    .

hstep (elim_setSigma Pair M Mm) (Mm Bb Cc) 
    :- spy(hnf Pair (pair B C Bb Cc))
    ,  spy(isa Bb B _)
    ,  spy(isa Cc (C Bb) _)
    ,  spy(pi z\ locDecl z (setSigma B C) => ofType (M z) _ IE)
    ,  spy(pi x \ pi y \
        locDecl x B  => locDecl y (C x) =>  
            isa (Mm x y) (M (pair B C x y))  IE)
    .


dconv (setSigma B C) (setSigma B' C') :- (conv B B'), (pi x\ locDecl x B => conv (C x) (C' x)).

dconv (pair B C BB CC) (pair B' C' BB' CC') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    ,  (conv BB BB')                             %% conv BB BB modificato in conv BB BB'
    ,  (conv CC CC')
    .

dconv (elim_setSigma Pair M MM) (elim_setSigma Pair' M' MM') 
    :- (conv Pair Pair')
    ,  (of Pair (setSigma B C) _)
    ,  (pi z\ locDecl z (setSigma B C) => conv (M z) (M' z))
    ,  (pi x\ pi y\  locDecl x B => locDecl y (C x) => conv (MM x y) (MM' x y))
    .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   TRADUZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

interp (setSigma B C) T :-
       interp B Bi,
       macro_interp B (x\xi\_\_\ interp (C x) (Ci xi)),
       T = (setSigma Bi Ci)
       .

interp (pair B C BB CC) T :-
       interp B Bi,
       of BB B' ext,                                     %% B' is the extensional type of BB
       	     						 %% convertible to the type B
       macro_interp B' (x\xi\_\_\ interp (C x) (Ci xi)),  		 	      	  	   
       interp_isa BB B' BBi,   
       interp_isa CC (C BB) CCi,			 
       T = (pair Bi Ci BBi CCi)                          %% Ci parametric on xi, which is the
       	   	       	   				 %% interpretation of an x:B', just like BBi
       .

setoid_eq (setSigma B C) P :-
       print "SETSIGMA SETOID_EQ\n",
       interp B Bi,
       setoid_eq B EquB,
       macro_interp B (x\xi\_\_\ (interp (C x) (Ci xi) ,
       		      		 setoid_eq (C x) (EquC xi))),		   %% Equality over Ci xi
       macro_tau B B (x\x'\h\xi\xi'\hi\ tau (C x) (C x') (FCC xi xi' hi)), %% Cast from type (C x) to (C x') with
       		     			       	     	      	     	   %% x,x':B
       %% using the projection macros inside the term P gives rise to problems for "ofType"
       %% this is the verbose (but working) solution. There exists an equality d between p1s and p1z such that
       %% p2z : (C p1z) and the cast to type (C p1z) of s2:(C p1s) are equal over type (C p1z)
       P = (s\z\
		exist (EquB (elim_setSigma s (_\B) (x\y\ x)) (elim_setSigma z (_\B) (x\y\ x)) ) d\
	     	    (
	     		(EquC (elim_setSigma z (_\B) (x\y\ x)))
	     		( (FCC (elim_setSigma s (_\B) (x\y\ x)) (elim_setSigma z (_\B) (x\y\ x)) d)
	     		        elim_setSigma s (_\ (C (elim_setSigma s (_\B) (x\y\ x)))) (x\y\ y))
	     		(elim_setSigma z (_\ (C (elim_setSigma z (_\B) (x\y\ x)))) (x\y\ y))
	             ))
	.

tau (setSigma B C) (setSigma B' C') P :-
    print "SETSIGMA TAU FUNCTION\n",
    interp (setSigma B' C') (setSigma Bi' Ci'),
    tau B B' FB,
    macro_tau B B' (x\x'\h\xi\xi'\hi\tau (C x) (C' x') (FC xi xi' hi)),
    	      	   			       %% given xi: Bi and xi':Bi' and hi intensional proof of their equality
					       %% return function from terms in (C x)int to terms in (C' x')int
					       
    %% macro_tau B B' (x\x'\h\xi\xi'\hi\ proof_eq x x' B (IntEqu xi xi')),
    %% P = (w\ elim_setSigma w (_\ setSigma Bi' Ci')	%% w: (setSigma Bi Ci)
    %%  	   		   (w1\ w2\ pair Bi' Ci'
    %%			   	    	 (FB w1)
    %%					 ( (FC w1 (FB w1) (IntEqu w1 (FB w1)))
    %%					       w2)))
    
    setoid_refl B Hi,
    P = w\ elim_setSigma w (_\ setSigma Bi' Ci')	%% w: (setSigma Bi Ci)
      	   		   (w1\ w2\ pair Bi' Ci'
			   	    	 (FB w1)
					 ( (FC w1 (FB w1) (Hi w1)) w2))     %% Uso di setoid_refl simile a quello in setPi.tau
					       	      	      	   	    %% per ottenere una prova di uguaglianza intensionale.
									    %% Non chiaro; passa i test s3, s4.
    .
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                UTILITY                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type p1, p2  A->A.	%% mttTerm->mttTerm? Needed for both ext and int pairs...
     	     		%% Currently unused
p1 Pair R :-
   of Pair (setSigma B C) IE,
   R = (elim_setSigma Pair (_\B) (x\y\ x) )
   .

p2 Pair R :-
   of Pair (setSigma B C) IE,
   p1 Pair R1,
   R = (elim_setSigma Pair (_\ (C R1)) (x\y\ y) )
   .