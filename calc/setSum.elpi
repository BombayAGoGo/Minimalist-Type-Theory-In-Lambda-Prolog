%%-- disjoint sum: setSum

type setSum mttType -> mttType -> mttType.
type inl, inr mttType -> mttType -> mttTerm -> mttTerm.
type elim_setSum (mttTerm -> mttType) -> mttTerm -> (mttTerm -> mttTerm) -> (mttTerm -> mttTerm) -> mttTerm.

%%Disjoint Sum Type

ofType (setSum A B) set IE :- ofType A KIND1 IE, ofType B KIND2 IE,
    pts_fun KIND1 KIND2 set.

of (inr A B Bb) (setSum A B) IE 
    :- ofType B _ IE
     , ofType A _ IE
     , isa Bb B IE
     .

of (inl A B Aa) (setSum A B) IE  
    :- ofType A _ IE
     , ofType B _ IE
     , isa Aa A IE
     .

of (elim_setSum C W Cl Cr) (C W) IE 
    :- spy (of W (setSum A B) IE)
     , spy (ofType (setSum A B) _ IE) 
     , spy (pi z\ locDecl z (setSum A B) => ofType (C z) _ IE)
     , spy (pi x\ locDecl x A => isa (Cl x) (C (inl A B x)) IE)
     , spy (pi y\ locDecl y B => isa (Cr y) (C (inr A B y)) IE) 
     .


hstep (elim_setSum _C W Cl _Cr) (Cl Wl) 
    :- hnf W (inl _A _B Wl)
    .

hstep (elim_setSum _C W _Cl Cr) (Cr Wr) 
    :- hnf W (inr _A _B Wr)
    .


dconv (setSum A B) (setSum A' B')
    :- conv A A'
    ,  conv B B'
    .

dconv (inr A B BB) (inr A' B' BB') 
    :- conv A A'
    ,  conv B B'
    ,  conv BB BB'
    .

dconv (inl A B AA) (inl A' B' AA')  
    :- conv A A'
    ,  conv B B'
    ,  conv AA AA'
    .

dconv (elim_setSum C W Cl Cr) (elim_setSum C' W' Cl' Cr') 
    :- conv W W'
    ,  isa W (setSum A B) _ 
    ,  pi z\ locDecl z (setSum A B) => conv (C z) (C' z)
    ,  pi x\ locDecl x A => conv (Cl x) (Cl' x)
    ,  pi y\ locDecl y B => conv (Cr y) (Cr' y)
    .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   ESTRAZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

starify_nonset_ops_type (setSum A B) Result
    :- starify_nonset_ops_type A A'
    ,  starify_nonset_ops_type B B'
    ,  Result = (setSum A' B')
    ,  !
    .

extract_set_ops_type (setSum A B) Result SetList
    :- extract_set_ops_type A A' AList
    ,  extract_set_ops_type B B' BList
    ,  concat [BList, AList] SetList
    ,  collapse_type (setSum A' B') Result
    ,  !
    .


starify_nonset_ops (inl A B AA) Result
    :- starify_nonset_ops_type A A'
    ,  starify_nonset_ops_type B B'
    ,  starify_nonset_ops AA AA'
    ,  Result = (inl A' B' AA')
    ,  !
    .

extract_set_ops (inl A B AA) Result SetList
    :- spy(extract_set_ops AA AA' AAList)
    ,  spy(extract_set_ops_type A A' AList)
    ,  spy(extract_set_ops_type B B' BList)
    ,  concat [AAList, BList, AList] SetList
    ,  spy(collapse_term (inl A' B' AA') Result [])
    ,  !
    .


starify_nonset_ops (inr A B BB) Result
    :- starify_nonset_ops_type A A'
    ,  starify_nonset_ops_type B B'
    ,  starify_nonset_ops BB BB'
    ,  Result = (inr A' B' BB')
    ,  !
    .

extract_set_ops (inr A B BB) Result SetList
    :- spy(extract_set_ops BB BB' BBList)
    ,  spy(extract_set_ops_type A A' AList)
    ,  spy(extract_set_ops_type B B' BList)
    ,  concat [BBList, BList, AList] SetList
    ,  spy(collapse_term (inr A' B' BB') Result [])
    ,  !
    .


starify_nonset_ops (elim_setSum C W Cl Cr) Result
    :- starify_nonset_ops W W'
    ,  isa W (setSum L R) @level
    ,  pi w\ locDecl w (setSum L R) => starify_nonset_ops_type (C w) (C' w)
    ,  pi l\ locDecl l L => starify_nonset_ops (Cl l) (Cl' l)
    ,  pi r\ locDecl r R => starify_nonset_ops (Cr r) (Cr' r)
    ,  Result = (elim_setSum C' W' Cl' Cr')
    ,  !
    .

%% (1 + B') -> A'  ==>  A'  (se passato direttamente)
collapse_term (elim_setSum _C (inl A _B _AA) Cl _Cr) Result []
    :- conv A extractor_singleton
    ,  extract_set_ops (Cl extractor_star) Result []
    ,  !
    .

%% (B' + 1) -> A'  ==>  A'  (se passato direttamente)
collapse_term (elim_setSum _C (inr _A B _BB) _Cl Cr) Result []
    :- conv B extractor_singleton
    ,  extract_set_ops (Cr extractor_star) Result []
    ,  !
    .

%% (N + B') -> 1  ==>  1  (se passato direttamente)
collapse_term (elim_setSum _C (inl A _B AA) Cl _Cr) Result ElimList
    :- pi a\ locDecl a A => isa (Cl a) extractor_singleton @level
    ,  extract_collapsing_input AA A _ ElimList
    ,  Result = extractor_star
    ,  !
    .

%% (B' + N) -> 1  ==>  1  (se passato direttamente)
collapse_term (elim_setSum _C (inr _A B BB) _Cl Cr) Result ElimList
    :- pi b\ locDecl b B => isa (Cr b) extractor_singleton @level
    ,  extract_collapsing_input BB B _ ElimList
    ,  Result = extractor_star
    ,  !
    .

%% (N + B') -> N  ==>  N -> N  (se passato direttamente)
collapse_term (elim_setSum _C (inl A _B AA) Cl _Cr) Result ElimList
    :- extract_set_ops (app (lambda A Cl) AA) Result ElimList
    ,  !
    .

%% (B' + N) -> N  ==>  N -> N  (se passato direttamente)
collapse_term (elim_setSum _C (inr _A B BB) _Cl Cr) Result ElimList
    :- extract_set_ops (app (lambda B Cr) BB) Result ElimList
    ,  !
    .

%% N + N -> 1  ==>  1
%% se uno dei tipi non fosse informativo, starei estraendo delle prop
collapse_term (elim_setSum _C W Cl Cr) Result ElimList
    :- of W (setSum A B) @level
    ,  pi a\ locDecl a A => isa (Cl a) extractor_singleton @level
    ,  pi b\ locDecl b B => isa (Cr b) extractor_singleton @level
    ,  ofType A KindA @level, is_informative KindA true
    ,  ofType B KindB @level, is_informative KindB true
    ,  extract_collapsing_input W (setSum A B) _ ElimList
    ,  Result = extractor_star
    ,  !
    .

extract_set_ops (elim_setSum C W Cl Cr) Result SetList
    :- extract_set_ops W W' WList
    ,  isa W (setSum L R) @level
    ,  pi w\ locDecl w (setSum L R) => extract_set_ops_type (C w) (C' w) CList
    ,  pi l\ locDecl l L => extract_set_ops (Cl l) (Cl' l) ClList
    ,  pi r\ locDecl r R => extract_set_ops (Cr r) (Cr' r) CrList
    ,  spy(collapse_term (elim_setSum C' W' Cl' Cr') Result ElimList)
    ,  spy(concat [ElimList, CrList, ClList, CList, WList] SetList)
    ,  !
    .

