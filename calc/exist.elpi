type exist mttType -> (mttTerm -> mttType) -> mttType.
type pair_exist mttType -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
type elim_exist mttTerm -> mttType -> (mttTerm -> mttTerm -> mttTerm) -> mttTerm.


ofType (exist B C) KIND IE
    :- ofType B KIND1 IE
    ,  (pi x\ locDecl x B  => ofType (C x) KIND2 IE)
    ,  pts_for KIND1 KIND2 KIND
    .

of (pair_exist B C BB CC) (exist B C) IE 
    :- spy(ofType (exist B C) _ IE)
    ,  spy(isa BB B IE)
    ,  spy(isa CC (C BB) IE)
    .

of (elim_exist Pair M MM) M IE 
    :- spy(isa Pair (exist B C) IE)
    ,  spy(isaType M propc IE)
    ,  (pi x \ pi y \ locDecl x B => locDecl y (C x) =>  
                spy(isa (MM x y) M IE))
    .

hstep (elim_exist W _M MM) (MM Bb Cc) 
    :- hnf W (pair_exist _B _C Bb Cc)
    .

dconv (pair_exist B C Bb Cc) (pair_exist B' C' Bb' Cc')
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    ,  (conv Bb Bb')
    ,  (conv Cc Cc')
    .

dconv (elim_exist Pair M Mm) (elim_exist Pair' M' Mm') 
    :- (conv Pair Pair')
    ,  (isa Pair (exist B C) IE_)
    ,  (pi x\ pi y\ locDecl x B => locDecl y (C x)
        => conv (Mm x y) (Mm' x y))
    ,  (conv M M')
    .

dconv (exist B C) (exist B' C') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    .


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   ESTRAZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

wrap_enlarged_sets_type (exist B C) Result
    :- ofType B KindB int
    ,  pi b\ locDecl b B => ofType (C b) KindC int
    ,  pts_for KindB KindC Kind
    ,  ((Kind = propc, KindB = set
        ,    WB = extractor_singleton)
        , !; WB = B)
    ,  spy(Result = (exist WB C))
    ,  !
    .

starify_nonset_ops_type (exist B C) Result
    :- wrap_enlarged_sets_type (exist B C) (exist WB C)
    ,  starify_nonset_ops_type WB B'
    ,  pi b\ locDecl b WB => starify_nonset_ops_type (C b) (C' b)
    ,  spy(Result = (exist B' C'))
    ,  !
    .

collapse_star_ops_type (exist B C) Result
    :- collapse_star_ops_type B B'
    ,  pi b\ locDecl b B => collapse_star_ops_type (C b) (C' b)
    ,  spy((B' = extractor_singleton, C' = (x\ extractor_singleton)
        ,    Result = extractor_singleton)
        , !; Result = (exist B' C'))
    ,  !
    .


wrap_enlarged_sets (pair_exist B C BB CC) Result
    :- ofType B KindB int
    ,  ofType (C BB) KindC int
    ,  pts_for KindB KindC Kind
    ,  ((Kind = propc, KindB = set
        ,    WBB = (app (lambda B (x\extractor_star)) BB), WB = extractor_singleton)
        , !; WBB = BB, WB = B)
    ,  spy(Result = (pair_exist WB C WBB CC))
    ,  !
    .

starify_nonset_ops (pair_exist B C BB CC) Result 
    :- spy(wrap_enlarged_sets (pair_exist B C BB CC) (pair_exist WB C WBB CC))
    ,  starify_nonset_ops WBB BB'
    ,  starify_nonset_ops CC CC'
    ,  starify_nonset_ops_type (exist WB C) (exist B' C')
    ,  spy(Result = (pair_exist B' C' BB' CC'))
    ,  !
    .

collapse_term (pair_exist extractor_singleton (_\ extractor_singleton) extractor_star extractor_star) Result []
    :- Result = extractor_star
    ,  !
    .

extract_set_ops (pair_exist B C BB CC) Result SetList
    :- extract_set_ops BB BB' BList
    ,  extract_set_ops CC CC' CList
    ,  concat [CList, BList] SetList
    ,  collapse_star_ops_type (exist B C) (exist B' C')
    ,  spy(collapse_term (pair_exist B' C' BB' CC') Result [])
    ,  !
    .


starify_nonset_ops (elim_exist Pair M MM) Result
    :- starify_nonset_ops Pair Pair'
    ,  isa Pair (exist B C) int
    ,  starify_nonset_ops_type M M'
    ,  pi b\ pi c\ locDecl b B => locDecl c (C b) => starify_nonset_ops (MM b c) (MM' b c)
    ,  Result = (elim_exist Pair' M' MM')
    ,  !
    .

collapse_term (elim_exist extractor_star _M MM) Result ElimList
    :- extract_set_ops (MM extractor_star extractor_star) Result ElimList
    ,  !
    .

extract_set_ops (elim_exist Pair M MM) Result SetList
    :- extract_set_ops Pair Pair' PairList
    ,  isa Pair (exist B C) int
    ,  collapse_star_ops_type M M'
    ,  pi b\ pi c\ locDecl b B => locDecl c (C b) => extract_set_ops (MM b c) (MM' b c) MMList
    ,  spy(collapse_term (elim_exist Pair' M' MM') Result ElimList)
    ,  concat [ElimList, MMList, PairList] SetList
    ,  !
    .

wrap_enlarged_sets_type (exist B C) Result
    :- ofType B KindB int
    ,  pi b\ locDecl b B => ofType (C b) KindC int
    ,  pts_for KindB KindC Kind
    ,  ((Kind = propc, KindB = set
        ,    WB = extractor_singleton)
        , !; WB = B)
    ,  spy(Result = (exist WB C))
    ,  !
    .

starify_nonset_ops_type (exist B C) Result
    :- wrap_enlarged_sets_type (exist B C) (exist WB C)
    ,  starify_nonset_ops_type WB B'
    ,  pi b\ locDecl b WB => starify_nonset_ops_type (C b) (C' b)
    ,  spy(Result = (exist B' C'))
    ,  !
    .

collapse_star_ops_type (exist B C) Result
    :- collapse_star_ops_type B B'
    ,  pi b\ locDecl b B => collapse_star_ops_type (C b) (C' b)
    ,  spy((B' = extractor_singleton, C' = (x\ extractor_singleton)
        ,    Result = extractor_singleton)
        , !; Result = (exist B' C'))
    ,  !
    .


wrap_enlarged_sets (pair_exist B C BB CC) Result
    :- ofType B KindB int
    ,  ofType (C BB) KindC int
    ,  pts_for KindB KindC Kind
    ,  ((Kind = propc, KindB = set
        ,    WBB = (app (lambda B (x\extractor_star)) BB), WB = extractor_singleton)
        , !; WBB = BB, WB = B)
    ,  spy(Result = (pair_exist WB C WBB CC))
    ,  !
    .

starify_nonset_ops (pair_exist B C BB CC) Result 
    :- spy(wrap_enlarged_sets (pair_exist B C BB CC) (pair_exist WB C WBB CC))
    ,  starify_nonset_ops WBB BB'
    ,  starify_nonset_ops CC CC'
    ,  starify_nonset_ops_type (exist WB C) (exist B' C')
    ,  spy(Result = (pair_exist B' C' BB' CC'))
    ,  !
    .

collapse_term (pair_exist extractor_singleton (_\ extractor_singleton) extractor_star extractor_star) Result []
    :- Result = extractor_star
    ,  !
    .

extract_set_ops (pair_exist B C BB CC) Result SetList
    :- extract_set_ops BB BB' BList
    ,  extract_set_ops CC CC' CList
    ,  concat [CList, BList] SetList
    ,  collapse_star_ops_type (exist B C) (exist B' C')
    ,  spy(collapse_term (pair_exist B' C' BB' CC') Result [])
    ,  !
    .


starify_nonset_ops (elim_exist Pair M MM) Result
    :- starify_nonset_ops Pair Pair'
    ,  isa Pair (exist B C) int
    ,  starify_nonset_ops_type M M'
    ,  pi b\ pi c\ locDecl b B => locDecl c (C b) => starify_nonset_ops (MM b c) (MM' b c)
    ,  Result = (elim_exist Pair' M' MM')
    ,  !
    .

collapse_term (elim_exist extractor_star _M MM) Result ElimList
    :- extract_set_ops (MM extractor_star extractor_star) Result ElimList
    ,  !
    .

extract_set_ops (elim_exist Pair M MM) Result SetList
    :- extract_set_ops Pair Pair' PairList
    ,  isa Pair (exist B C) int
    ,  collapse_star_ops_type M M'
    ,  pi b\ pi c\ locDecl b B => locDecl c (C b) => extract_set_ops (MM b c) (MM' b c) MMList
    ,  spy(collapse_term (elim_exist Pair' M' MM') Result ElimList)
    ,  concat [ElimList, MMList, PairList] SetList
    ,  !
    .

