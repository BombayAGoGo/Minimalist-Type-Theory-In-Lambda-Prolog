% will not exist at the emtt level, so no interpretation is needed

%%-- intensional propositional equality: propId

type propId mttType -> mttTerm -> mttTerm -> mttType.
type id     mttType -> mttTerm -> mttTerm.
type elim_id    mttTerm 
            -> (mttTerm -> mttTerm -> mttType) 
            -> (mttTerm -> mttTerm)
            -> mttTerm.



ofType (propId A AA1 AA2) KIND _IE
    :- ofType A KIND' int
    ,  pts_eq KIND' KIND
    ,  isa AA1 A int
    ,  isa AA2 A int
    .

of (id A AA) (propId A AA AA) int 
    :- spy(ofType A _ int)
    ,  spy(isa AA A int)
    .

of (elim_id P C CC) (C AA1 AA2) int
    :- spy(of P (propId A AA1 AA2) int)
    ,  spy(pi x\ pi y\ locDecl x A => locDecl y A => isaType (C x y) propc int)
    ,  spy(pi x\ locDecl x A => of (CC x) (C x x) int)
    .

hstep (elim_id (id _A AA) _C CC) (CC AA).

dconv (id A AA) (id A' AA') :- (conv A A'),(conv AA AA').

dconv (propId A AA1 AA2) (propId A' AA1' AA2') :- spy (conv A A'), spy (conv AA1 AA1'), spy(conv AA2 AA2').


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   ESTRAZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

wrap_enlarged_sets_type (propId A AA1 AA2) Result
    :- ofType A KindA int
    ,  ((KindA = set
        ,    WAA1 = (app (lambda A (x\extractor_star)) AA1), WAA2 = (app (lambda A (x\extractor_star)) AA2), WA = extractor_singleton)
        , !; WAA1 = AA1, WAA2 = AA2, WA = A)
    ,  spy(Result = (propId WA WAA1 WAA2))
    ,  !
    .

starify_nonset_ops_type (propId A AA1 AA2) Result
    :- wrap_enlarged_sets_type (propId A AA1 AA2) (propId WA WAA1 WAA2)
	,  starify_nonset_ops WAA1 AA1'
    ,  starify_nonset_ops WAA2 AA2'
    ,  starify_nonset_ops_type WA A'
    ,  spy(Result = (propId A' AA1' AA2'))
    ,  !
    .

collapse_star_ops_type (propId A AA1 AA2) Result
    :- extract_set_ops AA1 AA1' _AAList
    ,  extract_set_ops AA2 AA2' _AAList
    ,  collapse_star_ops_type A A'
    ,  spy((A' = extractor_singleton, AA1' = extractor_star, AA2' = extractor_star
        ,    Result = extractor_singleton)
        , !; Result = (propId A' AA1' AA2'))
    ,  !
    .


wrap_enlarged_sets (id A AA) Result
    :- ofType A KindA int
    ,  ((KindA = set
        ,    WAA = (app (lambda A (x\extractor_star)) AA), WA = extractor_singleton)
        , !; WAA = AA, WA = A)
    ,  spy(Result = (id WA WAA))
    ,  !
    .

starify_nonset_ops (id A AA) Result
    :- wrap_enlarged_sets (id A AA) (id WA WAA)
	,  starify_nonset_ops WAA AA'
    ,  starify_nonset_ops_type WA A'
    ,  spy(Result = (id A' AA'))
    ,  !
    .

collapse_term (id extractor_singleton extractor_star) Result []
    :- Result = extractor_star
    ,  !
    .

extract_set_ops (id A AA) Result SetList
    :- spy(extract_set_ops AA AA' SetList)
    ,  spy(collapse_star_ops_type A A')
    ,  spy(collapse_term (id A' AA') Result [])
    ,  !
    .


wrap_enlarged_sets (elim_id P C CC) Result
    :- pi x\ pi y\ locDecl x A => locDecl y A => ofType (C x y) KindC int
    ,  ((KindC = set
        ,    WCC = (z\ app (lambda (C P P) (x\extractor_star)) (CC z))), WC = (x\y\ extractor_singleton)
        , !; WCC = CC, WC = C)
    ,  spy(Result = (elim_id P WC WCC))
    ,  !
    .

starify_nonset_ops (elim_id P C CC) Result
    :- wrap_enlarged_sets (elim_id P C CC) (elim_id P WC WCC)
    ,  starify_nonset_ops P P'
    ,  isa P (propId A _ _) int
    ,  pi x\ locDecl x A => pi y\ locDecl y A => starify_nonset_ops_type (WC x y) (C' x y)
    ,  pi x\ locDecl x A => starify_nonset_ops (WCC x) (CC' x)
    ,  spy(Result = (elim_id P' C' CC'))
    ,  !
    .

collapse_term (elim_id extractor_star _C CC) Result ElimList
    :- extract_set_ops (CC extractor_star) Result ElimList
    ,  !
    .

extract_set_ops (elim_id P C CC) Result SetList
    :- extract_set_ops P P' IdList
    ,  isa P (propId A _ _) int
    ,  pi x\ locDecl x A => pi y\ locDecl y A => collapse_star_ops_type (C x y) (C' x y)
    ,  pi x\ locDecl x A => extract_set_ops (CC x) (CC' x) CCList
    ,  spy(collapse_term (elim_id P' C' CC') Result ElimList)
    ,  concat [ElimList, CCList, IdList] SetList
    ,  !
    .

