%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Dependent Products                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type setPi mttType -> (mttTerm -> mttType) -> mttType.
type lambda mttType -> (mttTerm -> mttTerm) -> mttTerm.
type app mttTerm -> mttTerm -> mttTerm.

ofType (setPi B C) KIND3 IE
    :- spy (ofType B KIND1 IE)
    ,  (pi x\ locDecl x B
        => spy (ofType (C x) KIND2 IE))
    ,  spy(pts_fun KIND1 KIND2 KIND3)
    .

of (lambda B F) (setPi B C) IE
    :- spy (ofType B _ IE)
    ,  spy (pi x\ locDecl x B => of (F x) (C x) IE)
    .

of (app Lam X) (CX) IE
    :- spy(isa Lam (setPi B C) IE)
    ,  spy(isa X B IE)
    ,  CX = C X
    .

hstep (app LAM Bb) (F Bb)
    :- (isa LAM (setPi B C) IE)
    ,  (ofType B _ IE)
    ,  (isa Bb B IE)
    ,  (hnf LAM (lambda B' F))
    ,  conv B B'
    ,  (pi x\ locDecl x B => isa (F x) (C x) IE)
    ,  (pi x\ locDecl x B => ofType (C x) _ IE)
    .

dconv (setPi B C) (setPi B' C') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    .
dconv (app F X) (app F' X') :- (conv F F'), (conv X X').

dconv (lambda B F) (lambda B' F') 
    :- (conv B B')
    ,  pi x\  locDecl x B => (conv (F x) (F' x)) 
    .
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                 Interpretation                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



interp (setPi B C) T 
    :- spy(macro_interp B x\xi\_\_\ interp (C x) (Ci xi))
    ,  spy(macro_interp B x\xi\_\_\ setoid_eq (C x) (EquC xi))
    ,  spy(interp B Bi)
    ,  spy(setoid_eq B EquB)
    ,  (macro_Pi B (x1\x2\h\x1i\x2i\hi\ tau (C x1) (C x2) (PippoC x1i x2i hi)))
    ,  T = setSigma (setPi Bi Ci) 
        f\ forall Bi 
         x1i\ forall Bi 
          x2i\ forall (EquB x1i x2i) 
           h\ EquC x2i (PippoC x1i x2i h (app f x1i)) (app f x2i)
    .


interp (app F X) R 
    :- spy(of F (setPi B C_) ext)
    ,  spy(interp_isa X B Xi)
    ,  spy(interp F Fi)
    ,  spy(of Fi T int)
    ,  spy(T = (setSigma PI _))
    ,  R = (app (elim_setSigma Fi (_\PI) (x\y\x) ) Xi)
    .


interp (lambda B F) R                
    :- spy(of (lambda B F) (setPi B C) ext)
    ,  spy(interp (setPi B C) (setSigma (setPi Bi Ci) H ))
    ,  spy(macro_tau B B ( x\_\_\xi\_\_\ interp (F x) (Fi xi)))
    ,  spy(setoid_eq B EquB)
    ,  spy(macro_tau B B (x1\x2\h\x1i\x2i\hi\proof_eq (F x1) (F x2) (C x2) (K_EQU x1i x2i hi)))
    ,  spy(R = pair (setPi Bi Ci) (H) (lambda Bi Fi)
        (forall_lam Bi x1\ forall_lam Bi x2\ forall_lam (EquB x1 x2) h\
            K_EQU x1 x2 h))
    .

%% The result P is an equality relation over the translation of (setPi B C). P takes two functions
%% and verifies that for each element in the (translated) domain, the corrisponding values in the
%% (translated) codomain are equal.
setoid_eq (setPi B C) P
    :- spy(interp B Bi)
    ,  spy(pi x\ pi xi\locDecl x B 
        => locDecl xi Bi
            => interp x xi
                => (interp (C x) (Ci xi), setoid_eq (C x) (EquC xi)))
    ,  P = (f\ g\ 
        forall Bi x\ 
            EquC x 
            (app (elim_setSigma f (_\setPi Bi Ci) (x\y\x) ) x) 
            (app (elim_setSigma g (_\setPi Bi Ci) (x\y\x) ) x))
    .
% Nota:
%   T is a concrete type, while C is not!
%   é la probabile causa di eventuali errori di arietà
proof_eq (app F1 X1) (app F2 X2) T H_app 
    :- of F1 (setPi B1_ C1) ext
    ,  of F2 (setPi B2_ C2_) ext
    ,  of X1 A1 ext
    ,  of X2 A2_ ext
%    ,  check (conv (C1 X1) T)
%    ,  check (conv (C2 X2) T)
%    ,  check (conv A1 B1)
%    ,  check (conv A2 B2)
%    ,  check (conv (setPi B2 C2) (setPi B1 C1))
    ,  C = C1, A = A1
    ,  X = X1, F = F1
    ,  X' = X2, F' = F2
    %  We need to use (setPi A C) in place of (setPi B C)
    %  because later we need (C X) to be interpreted as the inferred
    %  type of (app P1Fi Xi)
    ,  spy(proof_eq F F' (setPi A C) H_fun)
    ,  spy(proof_eq X X' A H_args)
    ,  setoid_tran (C X) P_tran
    ,  interp F Fi
    ,  interp_isa F' (setPi A C) Fi'
    ,  interp (setPi A C) (setSigma ACi PACi)
    ,  ACi = setPi Ai_ Ci_
    ,  interp_isa X A Xi
    ,  interp_isa X' A Xi'
    ,  P1Fi = elim_setSigma Fi (_\ACi) (a\b\a)
    ,  P2Fi = elim_setSigma Fi (x\PACi (elim_setSigma x (_\ACi) (a\b\a))) (a\b\b)
    ,  P1Fi' = elim_setSigma Fi' (_\ACi) (a\b\a)
    ,  H_app_in_CX = P_tran 
        (app P1Fi Xi)       %Ok 
        (app P1Fi Xi')      %Ok
        (app P1Fi' Xi')     %Ok
        (forall_app (forall_app (forall_app P2Fi Xi) Xi') H_args)   %Ok
        (forall_app H_fun Xi')  %Ok
    ,  spy(tau_eq (C X) T T_eq)
    ,  spy(H_app = T_eq (app P1Fi Xi) (app P1Fi' Xi') H_app_in_CX)

    % P_tran (app Fi Xi) (app Fi Xi') (app Fi' Xi') (forall_app (forall_app (forall_app (p2 Fi) Xi) Xi') H_args) (forall_app H_fun Xi')
    %       \in Fi Xi =_Ti Fi' Xi'
    % ora possiamo dimostrate Fi Xi =(via p2(Fi))= Fi Xi' =(via F = F')= Fi' Xi'
    % sarà molto lungo da scrivere a mano
    .

tau (setPi B C) (setPi B' C') P
    :- spy(interp (setPi B C) (setSigma T1 T2_))
    ,  spy(T1 = setPi Bi_ Ci_)
    ,  spy(interp (setPi B' C') (setSigma T1' T2'))
    ,  spy(T1' = setPi Bi' Ci'_)
    ,  spy(setoid_eq B' EquB')
    %,  spy(macro_tau B B (_\x2\_\_\x2i\hi\ setoid_eq (C x2) (EquC x2i)))
    ,  spy(tau B' B FB)
    ,  spy(macro_tau B B' 
        (x\x'\h\xi\xi'\hi\ tau (C x) (C' x') (FC' xi xi' hi)))
    ,  spy(macro_tau B B (x1\x2\_\x1i\x2i\hi\ tau (C x1) (C x2) (FCC x1i x2i hi)))
    ,  spy(tau_eq B' B KB)
    ,  spy(macro_tau B B' x\x'\_\xi\xi'\hi\ tau_eq (C x) (C' x') (KC' xi xi' hi))
    ,  spy(setoid_refl B Hi)
    ,  spy(pi y1'\ pi y2'\ pi d'\ sigma FH_2\ %Questo sigma interno server per far contento il typechecker
        (locDecl y1' Bi', locDecl y2' Bi', locDecl d' (EquB' y1' y2')) =>
                    (
                        tau_eq B' B  FH_2, FH_2 = (FH y1' y2' d') 
                    )
                    )
                    
    ,  spy(P = 
        (w\ elim_setSigma w (_\setSigma T1' T2')
            f\p\ pair T1' T2'
                (lambda Bi' x\ FC' (FB x) x (Hi (FB x)) (app f (FB x)))
                (forall_lam Bi' y1'\ forall_lam Bi' y2'\ forall_lam (EquB' y1' y2') d'\
                    KC' (FB y2') 
                        y2' 
                        d' 
                        (FCC (FB y1') (FB y2') (FH y1' y2' d') (app f (FB y1')))
                        (app f (FB y2'))
                        (forall_app
                          (forall_app
                            (forall_app p (FB y1'))
                            (FB y2'))
                          (KB y1' y2' d')
                         )
                )
        ) )
    . 


tau_eq (setPi B C) (setPi B' C') P 
    :- spy(macro_tau B B' x\x'\_\xi\xi'\hi\ tau_eq (C x) (C' x') (KC' xi xi' hi))
    ,  spy(tau B' B FB)
    ,  spy(interp B' Bi')
    ,  P = f\g\d\ forall_lam Bi' y'\ %% check
            KC' (FB y') 
                y'                  %% type mismatch: this should be intensional but it is not!
                d
                (app f (FB y'))
                (app g (FB y'))
                (forall_app d (FB y'))
    .
 

setoid_refl (setPi B C) H 
    :- spy(interp (setPi B C) SetPiBCi)
    ,  interp B Bi
    ,  (pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => interp (C y) (Ci yi))
    ,  spy(pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => setoid_refl (C y) (HC yi))
    ,  spy( H = z\ forall_lam Bi y\ (HC y (app (elim_setSigma z (z\setPi Bi Ci) a\b\a) y) ))
    ,  spy(setoid_eq (setPi B C) EquBC)
    ,  (pi z\ TypeH z = EquBC z z)
    ,  spy( pi z\ locDecl z SetPiBCi =>
        spy(of (H z) (TypeH z) int)
    )
    .

setoid_symm (setPi B C) H 
    :- spy(interp (setPi B C) SetPiBCi)
    ,  spy(setoid_eq (setPi B C) EquBC)
    ,  interp B Bi
    ,  (pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => interp (C y) (Ci yi))
    ,  spy(pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => setoid_symm (C y) (HC yi))
    ,  spy( H = f\g\h\ forall_lam Bi 
          yi\ HC yi 
          (app (elim_setSigma f (z\setPi Bi Ci) a\b\a) yi) 
          (app (elim_setSigma g (z\setPi Bi Ci) a\b\a) yi) 
          (forall_app h yi)
    )
    ,  spy( pi f\ pi g\ pi h\ locDecl f SetPiBCi => locDecl g SetPiBCi => locDecl h (EquBC f g) =>
            spy( of (H f g h) (EquBC g f) int
            )
    )
    .

setoid_tran (setPi B C) H 
    :- interp B Bi
    ,  (pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => interp (C y) (Ci yi))
    ,  spy(pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => setoid_tran (C y) (HC yi))
    ,  spy( H = f\g\h\p\q\ forall_lam Bi yi\ 
            HC yi 
            (app (elim_setSigma f (z\setPi Bi Ci) a\b\a) yi)
            (app (elim_setSigma g (z\setPi Bi Ci) a\b\a) yi)
            (app (elim_setSigma h (z\setPi Bi Ci) a\b\a) yi)
            (forall_app p yi)
            (forall_app q yi)
    )
    .

%%%%%%%%%%%%%%%%%%
%   LIBRARY		
%%%%%%%%%%%%%%%%%%

type setPiLib list libraryEntry -> prop.
type respect mttType -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm -> mttType.
type respectDep mttType -> (mttTerm -> mttType) -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm -> mttTerm -> mttTerm -> mttType. 
type setPi_setoid mttType -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
type setPi_setoidDep mttType -> (mttTerm -> mttType) -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm -> mttTerm.
type setPi_setoidRel mttType -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
setPiLib Lp :-
   (pi Bi \ pi Ci \ pi w \ locDecl w (setSigma Bi Ci) => (p1 w (P1 Bi Ci w), p2 w (P2 Bi Ci w))),
   Lp = [
   (univPi Bi\
    univDepPi Bi Ci\
     univPiT (setoid Bi) bS\
     univPiT (setoidDep Bi Ci bS) cS\
     univPiT (setPi Bi Ci) h\
      locTypeDefL (respect Bi Ci bS cS h) props (forall Bi y1\ forall Bi y2\ forall (decode (app (app (app (setoid_rel Bi) bS) y1 ) y2)) d\
                       	             decode (app (app (app (setoid_rel (Ci y2)) (app (app (setoidDepCarrier Bi Ci bS) cS) y2))
                                     	     	 (app (app (app (app (app (setoidDepCast Bi Ci bS) cS) y1) y2) d) (app h y1)))
                              	   	     	 (app h y2)))),
   (
    univPi Ai\
    univDepPi Ai Bi\
    univDepPi (setSigma Ai Bi) Ci\
     univPiT (setoid Ai) aS\
     univPiT (setoidDep Ai Bi aS) bS\
     univPiT (setoidDep (setSigma Ai Bi) Ci (setSigma_setoid Ai Bi aS bS)) cS\
     univPiT Ai a\
     univPiT (setPi (Bi a) (b\ Ci (pair Ai Bi a b))) h\
     hyp (pi x\ isa x Ai int => pi y \ isa y (Bi x) int =>
             conv y (app (app (app (app (app (setoidDepCast Ai Bi aS) bS) x) x) (forall_app (app (setoid_reflL Ai) aS) x)) y))
         (pi x\ locDecl x Ai => pi y \ locDecl y (Bi x) =>
             spy (conv y (app (app (app (app (app (setoidDepCast Ai Bi aS) bS) x) x) (forall_app (app (setoid_reflL Ai) aS) x)) y)))
      (locTypeDefL (respectDep Ai Bi Ci aS bS cS h a) props (respect (Bi a) (b\ Ci (pair Ai Bi a b))
					      	       	    (app (app (setoidDepCarrier Ai Bi aS) bS) a)
						              (app (gamma_setoidDep Ai Bi Ci aS bS cS) a) h))),
   % setPi_setoidRel
   (univPi Bi\
    univDepPi Bi Ci\
     univPiT (setoid Bi) bS\
     univPiT (setoidDep Bi Ci bS) cS\
      (locDefL (setPi_setoidRel Bi Ci bS cS)
               (setPi (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) _\
	         setPi (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) _\ propS)
	       (lambda (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) z1\
		       lambda (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) z2\
		        encode (forall Bi y\
			  decode (app (app (app (setoid_rel (Ci y)) (app (app (setoidDepCarrier Bi Ci bS) cS) y))
			  	      (app (P1 (setPi Bi Ci) (h\ respect Bi Ci bS cS h) z1) y))
				      (app (P1 (setPi Bi Ci) (h\ respect Bi Ci bS cS h) z2) y)))))),
   % setPi_setoid
   (univPi Bi\
   univDepPi Bi Ci\
    univPiT (setoid Bi) bS\
    univPiT (setoidDep Bi Ci bS) cS \
     (locDefL (setPi_setoid Bi Ci bS cS) (setoid (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))))
             (pair (setPi (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) _\
	       	      	setPi (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) _\ propS)
             	   (rel \ and (forall (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) x \ decode (app (app rel x) x))
		      	      (forall (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) x1\
			       (forall (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) x2\
				 setPi (decode (app (app rel x1) x2)) h\ (decode (app (app rel x2) x1)))))
		   % the setoid relation
		   (setPi_setoidRel Bi Ci bS cS)
		   (pair_and (forall (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) x \
		                decode (app (app (setPi_setoidRel Bi Ci bS cS) x) x))
			    (forall (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) x1\
			       (forall (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) x2\
				 setPi (decode (app (app (setPi_setoidRel Bi Ci bS cS) x1) x2)) h\
				  (decode (app (app (setPi_setoidRel Bi Ci bS cS) x2) x1))))
		            % proof of reflexivity
		      	    (forall_lam (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) z\
		       	      forall_lam Bi y\
		                forall_app (app (setoid_reflL (Ci y)) (app (app (setoidDepCarrier Bi Ci bS) cS) y))
				   	(app (P1 (setPi Bi Ci) (h\ respect Bi Ci bS cS h) z) y))
			    % proof of symmetry
			    (fixMe "setPi_setoid symmetry"
			    	   (forall (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) x1\
			       	    (forall (setSigma (setPi Bi Ci) (h\ (respect Bi Ci bS cS h))) x2\
				     setPi (decode (app (app (setPi_setoidRel Bi Ci bS cS) x1) x2)) h\
				      (decode (app (app (setPi_setoidRel Bi Ci bS cS) x2) x1))))))))),
    % setPi_setoidDep
    (univPi Ai\
     univDepPi Ai Bi\
     univDepPi (setSigma Ai Bi) Ci\
      univPiT (setoid Ai) aS\
      univPiT (setoidDep Ai Bi aS) bS\
      univPiT (setoidDep (setSigma Ai Bi) Ci (setSigma_setoid Ai Bi aS bS)) cS\
      %hyp debug debug
      (hyp
	(pi x\ isa x Ai int => pi y \ isa y (Bi x) int =>
          conv y (app (app (app (app (app (setoidDepCast Ai Bi aS) bS) x) x) (forall_app (app (setoid_reflL Ai) aS) x)) y))
        (pi x\ locDecl x Ai => pi y \ locDecl y (Bi x) =>
          spy (conv y (app (app (app (app (app (setoidDepCast Ai Bi aS) bS) x) x) (forall_app (app (setoid_reflL Ai) aS) x)) y)))
      (locDefL (setPi_setoidDep Ai Bi Ci aS bS cS)
               (setoidDep Ai (a\ setSigma (setPi (Bi a) (b\ Ci (pair Ai Bi a b)))
	       		     	 	  (h\ (respectDep Ai Bi Ci aS bS cS h a ))) aS)
	       (pair (setPi Ai a\ setoid (setSigma (setPi (Bi a) (b\ Ci (pair Ai Bi a b)))
	       	    	      	 		  (h\ (respectDep Ai Bi Ci aS bS cS h a ))))
		     (_\ setPi Ai a1\
		         setPi Ai a2\
		          setPi (decode (app (app (app (setoid_rel Ai) aS) a1) a2)) d\
		      	   setPi (setSigma (setPi (Bi a1) (b\ Ci (pair Ai Bi a1 b)))
	       	    	      	 		  (h\ (respectDep Ai Bi Ci aS bS cS h a1 ))) _\
			      setSigma (setPi (Bi a2) (b\ Ci (pair Ai Bi a2 b)))
	       	    	      	 		  (h\ (respectDep Ai Bi Ci aS bS cS h a2 )))
		    % Carrier Term
		    (lambda Ai a\
		     	     (setPi_setoid (Bi a) (b\ Ci (pair Ai Bi a b)) (app (app (setoidDepCarrier Ai Bi aS) bS) a)
			        (app (gamma_setoidDep Ai Bi Ci aS bS cS) a)))
		   % Cast Term
		   (lambda Ai a1\
		    lambda Ai a2\
		     lambda (decode (app (app (app (setoid_rel Ai) aS) a1) a2)) d\
		      lambda (setSigma (setPi (Bi a1) (b\ Ci (pair Ai Bi a1 b))) (h\ (respectDep Ai Bi Ci aS bS cS h a1 ))) w\
		       (elim_setSigma w (_\ (setSigma (setPi (Bi a2) (b\ Ci (pair Ai Bi a2 b))) (h\ (respectDep Ai Bi Ci aS bS cS h a2 ))))
		         (f\ p\
			 (pair (setPi (Bi a2) (b\ Ci (pair Ai Bi a2 b)))
			       (h\ (respectDep Ai Bi Ci aS bS cS h a2 ))
			       
			       (fixMe "function" (setPi (Bi a2) (b\ Ci (pair Ai Bi a2 b))) )
			       /* (lambda (Bi a2) x\
			       (app (app (app (app (app (setoidDepCast (setSigma Ai Bi) Ci (setSigma_setoid Ai Bi aS bS)) cS)
			       	    (pair Ai Bi a1 (app (app ( app (app (app (setoidDepCast Ai Bi aS) bS) a2) a1)
				    	     	   	(fixMe "symm d" (decode (app (app (app (setoid_rel Ai) aS) a2) a1)))) x)))
				    (pair Ai Bi a2 x))
				    (forall_app (app (setoid_reflL (setSigma Ai Bi)) (setSigma_setoid Ai Bi aS bS)) 
				    		(pair Ai Bi a1 (app (app ( app (app (app (setoidDepCast Ai Bi aS) bS) a2) a1)
						      	       	 (fixMe "symm d" (decode (app (app (app (setoid_rel Ai) aS) a2) a1)))) x))))
			       	    (app f (app (app (app (app (app (setoidDepCast Ai Bi aS) bS) a2) a1)
				    	   	(fixMe "symm d" (decode (app (app (app (setoid_rel Ai) aS) a2) a1)))) x)))) */
				    

		  (fixMe "proof" (respectDep Ai Bi Ci aS bS cS (fixMe "function" (setPi (Bi a2) (b\ Ci (pair Ai Bi a2 b))) ) a2))))))))))
						
  ]. 
 