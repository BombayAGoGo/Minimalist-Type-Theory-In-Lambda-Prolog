
%% calc_Eq.elpi


type propEq mttType -> mttTerm -> mttTerm -> mttType.
type eq   mttType -> mttTerm -> mttTerm.

ofType (propEq A AA1 AA2) KIND ext
    :- spy(ofType A KIND' ext)
    ,  spy(pts_eq KIND' KIND)
    ,  spy(isa AA1 A ext)
    ,  spy(isa AA2 A ext)
    .


of (eq C Cc) (propEq C Cc Cc) ext
    :-  spy(of Cc C ext)
    .



%dstep A B :- of _ ()

dconv (propEq A AA1 AA2) (propEq A' AA1' AA2') :- spy(conv A A'), spy(conv AA1 AA1'), spy (conv AA2 AA2').

dconv (eq A AA) (eq A' AA') :- conv A A', conv AA AA'.


interp (propEq A Aa1 Aa2) R 
    :- spy(setoid_eq A EquA)
    ,  spy(interp_isa Aa1 A Aa1i')
    ,  spy(interp_isa Aa2 A Aa2i')
    ,  spy(R = (EquA Aa1i' Aa2i'))
    .

interp (eq  A Aa)  T
    :- spy(setoid_refl A ReflA)
    ,  spy(interp Aa Aa')
    ,  T = (ReflA Aa') 
    .
tau (propEq T_ T1 T2) (propEq T T1' T2') (F)
    :- spy(conv T_ T)
    ,  spy(proof_eq T1 T1' T F1)
    ,  spy(proof_eq T2 T2' T F2)
    ,  spy(interp_isa T1 T T1i)
    ,  spy(interp_isa T2 T T2i)
    ,  spy(interp_isa T1' T T1i')
    ,  spy(interp_isa T2' T T2i')
    ,  spy(interp T Ti)
    ,  spy(F = x\ impl_app ( 
                impl_app ( 
                 forall_app ( 
                  forall_app ( 
                   impl_app ( 
                    forall_app ( 
                     forall_app (k_propId Ti) T1i) T1i') F1) T2i) T2i') F2) x
        )
    .

tau_eq (propEq _ _ _ ) (propEq _ _ _) (h\h'\k\ k).



proof_eq  _ _ (propEq _T _A _B) (id singleton star).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   ESTRAZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

starify_nonset_ops_type (propEq A AA1 AA2) Result
    :- starify_nonset_ops AA1 AA1'
    ,  starify_nonset_ops AA2 AA2'
    ,  starify_nonset_ops_type A A'
    ,  spy(Result = (propEq A' AA1' AA2'))
    ,  !
    .

collapse_type (propEq A _AA1 _AA2) Result
    :- conv A extractor_singleton
    ,  Result = extractor_singleton
    ,  !
    .

extract_set_ops_type (propEq A AA1 AA2) Result SetList
    :- extract_set_ops AA1 AA11 AA1List
    ,  extract_set_ops AA2 AA21 AA2List
    ,  extract_set_ops_type A A1 AList
    ,  extract_collapsing_input AA11 A1 K1 AA11List
    ,  extract_collapsing_input AA21 A1 K1 AA21List
    ,  spy((is_informative K1 false
        ,    A' = A1, AA1' = AA11, AA2' = AA21)
        , !; A' = extractor_singleton, AA1' = extractor_star, AA2' = extractor_star)
    ,  spy(concat [AA21List, AA11List, AA2List, AA1List, AList] SetList)
    ,  spy(collapse_type (propEq A' AA1' AA2') Result)
    ,  !
    .


starify_nonset_ops (eq A AA) Result
    :- starify_nonset_ops AA AA'
    ,  starify_nonset_ops_type A A'
    ,  spy(Result = (eq A' AA'))
    ,  !
    .

%% C 1  ==>  1
collapse_term (eq A _AA) Result []
    :- conv A extractor_singleton
    ,  Result = extractor_star
    ,  !
    .

%% A' -> C A'  ==>  A' -> C 1
extract_set_ops (eq A AA) Result SetList
    :- spy(extract_set_ops_type A A1 AList)
    ,  spy(extract_set_ops AA AA1 AAList)
    ,  spy(extract_collapsing_input AA1 A1 K1 AA1List)
    ,  spy((is_informative K1 false
        ,    A' = A1, AA' = AA1)
        , !; A' = extractor_singleton, AA' = extractor_star)
    ,  spy(concat [AA1List, AAList, AList] SetList)
    ,  spy(collapse_term (eq A' AA') Result [])
    ,  !
    .

