
%% calc_Eq.elpi


type propEq mttType -> mttTerm -> mttTerm -> mttType.
type eq   mttType -> mttTerm -> mttTerm.

ofType (propEq A AA1 AA2) KIND ext 
    :- ofType A KIND' ext
    ,  pts_eq KIND' KIND
    ,  isa AA1 A ext
    ,  isa AA2 A ext
    .


of (eq C Cc) (propEq C Cc Cc) ext
    :-  spy(of Cc C ext)
    .



%dstep A B :- of _ ()

dconv (propEq A AA1 AA2) (propEq A' AA1' AA2') :- spy(conv A A'), spy(conv AA1 AA1'), spy (conv AA2 AA2').

dconv (eq A AA) (eq A' AA') :- conv A A', conv AA AA'.


interp (propEq A Aa1 Aa2) R 
    :- spy(setoid_eq A EquA)
    ,  spy(interp_isa Aa1 A Aa1i')
    ,  spy(interp_isa Aa2 A Aa2i')
    ,  spy(R = (EquA Aa1i' Aa2i'))
    .

interp (eq  A Aa)  T
    :- spy(setoid_refl A ReflA)
    ,  spy(interp Aa Aa')
    ,  T = (ReflA Aa') 
    .
tau (propEq T_ T1 T2) (propEq T T1' T2') (F)
    :- spy(conv T_ T)
    ,  spy(proof_eq T1 T1' T F1)
    ,  spy(proof_eq T2 T2' T F2)
    ,  spy(interp_isa T1 T T1i)
    ,  spy(interp_isa T2 T T2i)
    ,  spy(interp_isa T1' T T1i')
    ,  spy(interp_isa T2' T T2i')
    ,  spy(interp T Ti)
    ,  spy(F = x\ impl_app ( 
                impl_app ( 
                 forall_app ( 
                  forall_app ( 
                   impl_app ( 
                    forall_app ( 
                     forall_app (k_propId Ti) T1i) T1i') F1) T2i) T2i') F2) x
        )
    .

tau_eq (propEq _ _ _ ) (propEq _ _ _) (h\h'\k\ k).



proof_eq  _ _ (propEq _T _A _B) (id singleton star).


/* NEW INTERPRETATION AND LIBRARY */
type propEqLib list libraryEntry -> prop.
type propEq_setoidDep mttType -> (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm -> mttTerm -> mttTerm.

new_interp_type (propEq A Aa1 Aa2) O :-
  spy(interp A Ai),
  new_interp_type A As,
     % Aa1 and Aa2 should be both of ext type A
  spy(interp_isa Aa1 A Aa1i),
  spy(interp_isa Aa2 A Aa2i),
  O = (prop_setoid (setoid (decode (app (app (app (setoid_rel Ai) AS) Aa1i) Aa2i)))).

new_interp_dep_type A (a\ (propEq (B a) Bb1 Bb2)) O :-
  spy(interp A Ai),
  macro_interp A (a\ai\_\_\ interp (B a) (Bi ai)),
  macro_interp A (a\ai\_\_\ (interp_isa Bb1 (B a) Bb1i, interp_isa Bb2 (B a) Bb2i)),
  new_interp_type A As,
  new_interp_dep_type A B Bs,
  O = (propEq_setoidDep Ai Bi As Bs Bb1i Bb2i).
  %% Bb1i and Bb2i declarations with univPiT would require to know an element ai of Ai
  %% possibly need a new abstraction mechanism for terms of dependent types (univDepPiT)



